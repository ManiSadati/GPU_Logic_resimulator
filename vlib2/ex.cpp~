class GEN_AND2_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  AND (z, a1, a2);
}
static void function(VAL &a1,VAL &a2,VAL &z){
  AND (z, a1, a2);
}
};
class GEN_AND2_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  AND (z, a1, a2);
}
static void function(VAL &a1,VAL &a2,VAL &z){
  AND (z, a1, a2);
}
};
class GEN_AND2_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  AND (z, a1, a2);
}
static void function(VAL &a1,VAL &a2,VAL &z){
  AND (z, a1, a2);
}
};
class GEN_AND2_D8:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  AND (z, a1, a2);
}
static void function(VAL &a1,VAL &a2,VAL &z){
  AND (z, a1, a2);
}
};
class GEN_AND3_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  AND (z, a1, a2, a3);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &z){
  AND (z, a1, a2, a3);
}
};
class GEN_AND3_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  AND (z, a1, a2, a3);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &z){
  AND (z, a1, a2, a3);
}
};
class GEN_AND3_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  AND (z, a1, a2, a3);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &z){
  AND (z, a1, a2, a3);
}
};
class GEN_AND3_D8:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  AND (z, a1, a2, a3);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &z){
  AND (z, a1, a2, a3);
}
};
class GEN_AND4_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL a4=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  AND (z, a1, a2, a3, a4);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &a4,VAL &z){
  AND (z, a1, a2, a3, a4);
}
};
class GEN_AND4_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL a4=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  AND (z, a1, a2, a3, a4);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &a4,VAL &z){
  AND (z, a1, a2, a3, a4);
}
};
class GEN_AND4_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL a4=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  AND (z, a1, a2, a3, a4);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &a4,VAL &z){
  AND (z, a1, a2, a3, a4);
}
};
class GEN_AND4_D8:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL a4=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  AND (z, a1, a2, a3, a4);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &a4,VAL &z){
  AND (z, a1, a2, a3, a4);
}
};
class GEN_AO211_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b=X;
  VAL c=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X;
  AND (net0, a1, a2);
  OR (z, net0, b, c);
}
static void function(VAL &a1,VAL &a2,VAL &b,VAL &c,VAL &z){
  VAL net0=X;
  AND (net0, a1, a2);
  OR (z, net0, b, c);
}
};
class GEN_AO211_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b=X;
  VAL c=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X;
  AND (net0, a1, a2);
  OR (z, net0, b, c);
}
static void function(VAL &a1,VAL &a2,VAL &b,VAL &c,VAL &z){
  VAL net0=X;
  AND (net0, a1, a2);
  OR (z, net0, b, c);
}
};
class GEN_AO211_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b=X;
  VAL c=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X;
  AND (net0, a1, a2);
  OR (z, net0, b, c);
}
static void function(VAL &a1,VAL &a2,VAL &b,VAL &c,VAL &z){
  VAL net0=X;
  AND (net0, a1, a2);
  OR (z, net0, b, c);
}
};
class GEN_AO21_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X;
  AND (net0, a1, a2);
  OR (z, net0, b);
}
static void function(VAL &a1,VAL &a2,VAL &b,VAL &z){
  VAL net0=X;
  AND (net0, a1, a2);
  OR (z, net0, b);
}
};
class GEN_AO21_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X;
  AND (net0, a1, a2);
  OR (z, net0, b);
}
static void function(VAL &a1,VAL &a2,VAL &b,VAL &z){
  VAL net0=X;
  AND (net0, a1, a2);
  OR (z, net0, b);
}
};
class GEN_AO21_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X;
  AND (net0, a1, a2);
  OR (z, net0, b);
}
static void function(VAL &a1,VAL &a2,VAL &b,VAL &z){
  VAL net0=X;
  AND (net0, a1, a2);
  OR (z, net0, b);
}
};
class GEN_AO221_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b1=X;
  VAL b2=X;
  VAL c=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X;
  AND (net0, a1, a2);
  AND (net1, b1, b2);
  OR (z, net0, net1, c);
}
static void function(VAL &a1,VAL &a2,VAL &b1,VAL &b2,VAL &c,VAL &z){
  VAL net0=X, net1=X;
  AND (net0, a1, a2);
  AND (net1, b1, b2);
  OR (z, net0, net1, c);
}
};
class GEN_AO221_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b1=X;
  VAL b2=X;
  VAL c=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X;
  AND (net0, a1, a2);
  AND (net1, b1, b2);
  OR (z, net0, net1, c);
}
static void function(VAL &a1,VAL &a2,VAL &b1,VAL &b2,VAL &c,VAL &z){
  VAL net0=X, net1=X;
  AND (net0, a1, a2);
  AND (net1, b1, b2);
  OR (z, net0, net1, c);
}
};
class GEN_AO221_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b1=X;
  VAL b2=X;
  VAL c=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X;
  AND (net0, a1, a2);
  AND (net1, b1, b2);
  OR (z, net0, net1, c);
}
static void function(VAL &a1,VAL &a2,VAL &b1,VAL &b2,VAL &c,VAL &z){
  VAL net0=X, net1=X;
  AND (net0, a1, a2);
  AND (net1, b1, b2);
  OR (z, net0, net1, c);
}
};
class GEN_AO222_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b1=X;
  VAL b2=X;
  VAL c1=X;
  VAL c2=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X, net2=X;
  AND (net0, c1, c2);
  AND (net1, a1, a2);
  AND (net2, b1, b2);
  OR  (z, net0, net1, net2);
}
static void function(VAL &a1,VAL &a2,VAL &b1,VAL &b2,VAL &c1,VAL &c2,VAL &z){
  VAL net0=X, net1=X, net2=X;
  AND (net0, c1, c2);
  AND (net1, a1, a2);
  AND (net2, b1, b2);
  OR  (z, net0, net1, net2);
}
};
class GEN_AO222_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b1=X;
  VAL b2=X;
  VAL c1=X;
  VAL c2=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X, net2=X;
  AND (net0, c1, c2);
  AND (net1, a1, a2);
  AND (net2, b1, b2);
  OR  (z, net0, net1, net2);
}
static void function(VAL &a1,VAL &a2,VAL &b1,VAL &b2,VAL &c1,VAL &c2,VAL &z){
  VAL net0=X, net1=X, net2=X;
  AND (net0, c1, c2);
  AND (net1, a1, a2);
  AND (net2, b1, b2);
  OR  (z, net0, net1, net2);
}
};
class GEN_AO222_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b1=X;
  VAL b2=X;
  VAL c1=X;
  VAL c2=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X, net2=X;
  AND (net0, c1, c2);
  AND (net1, a1, a2);
  AND (net2, b1, b2);
  OR  (z, net0, net1, net2);
}
static void function(VAL &a1,VAL &a2,VAL &b1,VAL &b2,VAL &c1,VAL &c2,VAL &z){
  VAL net0=X, net1=X, net2=X;
  AND (net0, c1, c2);
  AND (net1, a1, a2);
  AND (net2, b1, b2);
  OR  (z, net0, net1, net2);
}
};
class GEN_AO22_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b1=X;
  VAL b2=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X;
  AND (net0, b1, b2);
  AND (net1, a1, a2);
  OR  (z, net0, net1);
}
static void function(VAL &a1,VAL &a2,VAL &b1,VAL &b2,VAL &z){
  VAL net0=X, net1=X;
  AND (net0, b1, b2);
  AND (net1, a1, a2);
  OR  (z, net0, net1);
}
};
class GEN_AO22_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b1=X;
  VAL b2=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X;
  AND (net0, b1, b2);
  AND (net1, a1, a2);
  OR  (z, net0, net1);
}
static void function(VAL &a1,VAL &a2,VAL &b1,VAL &b2,VAL &z){
  VAL net0=X, net1=X;
  AND (net0, b1, b2);
  AND (net1, a1, a2);
  OR  (z, net0, net1);
}
};
class GEN_AO22_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b1=X;
  VAL b2=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X;
  AND (net0, b1, b2);
  AND (net1, a1, a2);
  OR  (z, net0, net1);
}
static void function(VAL &a1,VAL &a2,VAL &b1,VAL &b2,VAL &z){
  VAL net0=X, net1=X;
  AND (net0, b1, b2);
  AND (net1, a1, a2);
  OR  (z, net0, net1);
}
};
class GEN_AO22_D8:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b1=X;
  VAL b2=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X;
  AND (net0, b1, b2);
  AND (net1, a1, a2);
  OR  (z, net0, net1);
}
static void function(VAL &a1,VAL &a2,VAL &b1,VAL &b2,VAL &z){
  VAL net0=X, net1=X;
  AND (net0, b1, b2);
  AND (net1, a1, a2);
  OR  (z, net0, net1);
}
};
class GEN_AO31_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL b=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X;
  AND (net0, a1, a2, a3);
  OR (z, net0, b);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &b,VAL &z){
  VAL net0=X;
  AND (net0, a1, a2, a3);
  OR (z, net0, b);
}
};
class GEN_AO31_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL b=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X;
  AND (net0, a1, a2, a3);
  OR (z, net0, b);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &b,VAL &z){
  VAL net0=X;
  AND (net0, a1, a2, a3);
  OR (z, net0, b);
}
};
class GEN_AO31_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL b=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X;
  AND (net0, a1, a2, a3);
  OR (z, net0, b);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &b,VAL &z){
  VAL net0=X;
  AND (net0, a1, a2, a3);
  OR (z, net0, b);
}
};
class GEN_AO32_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL b1=X;
  VAL b2=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X;
  AND (net0, b1, b2);
  AND (net1, a1, a2, a3);
  OR (z, net0, net1);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &b1,VAL &b2,VAL &z){
  VAL net0=X, net1=X;
  AND (net0, b1, b2);
  AND (net1, a1, a2, a3);
  OR (z, net0, net1);
}
};
class GEN_AO32_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL b1=X;
  VAL b2=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X;
  AND (net0, b1, b2);
  AND (net1, a1, a2, a3);
  OR (z, net0, net1);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &b1,VAL &b2,VAL &z){
  VAL net0=X, net1=X;
  AND (net0, b1, b2);
  AND (net1, a1, a2, a3);
  OR (z, net0, net1);
}
};
class GEN_AO32_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL b1=X;
  VAL b2=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X;
  AND (net0, b1, b2);
  AND (net1, a1, a2, a3);
  OR (z, net0, net1);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &b1,VAL &b2,VAL &z){
  VAL net0=X, net1=X;
  AND (net0, b1, b2);
  AND (net1, a1, a2, a3);
  OR (z, net0, net1);
}
};
class GEN_AO33_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL b1=X;
  VAL b2=X;
  VAL b3=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X;
  AND (net0, b1, b2, b3);
  AND (net1, a1, a2, a3);
  OR (z, net0, net1);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &b1,VAL &b2,VAL &b3,VAL &z){
  VAL net0=X, net1=X;
  AND (net0, b1, b2, b3);
  AND (net1, a1, a2, a3);
  OR (z, net0, net1);
}
};
class GEN_AO33_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL b1=X;
  VAL b2=X;
  VAL b3=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X;
  AND (net0, b1, b2, b3);
  AND (net1, a1, a2, a3);
  OR (z, net0, net1);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &b1,VAL &b2,VAL &b3,VAL &z){
  VAL net0=X, net1=X;
  AND (net0, b1, b2, b3);
  AND (net1, a1, a2, a3);
  OR (z, net0, net1);
}
};
class GEN_AO33_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL b1=X;
  VAL b2=X;
  VAL b3=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X;
  AND (net0, b1, b2, b3);
  AND (net1, a1, a2, a3);
  OR (z, net0, net1);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &b1,VAL &b2,VAL &b3,VAL &z){
  VAL net0=X, net1=X;
  AND (net0, b1, b2, b3);
  AND (net1, a1, a2, a3);
  OR (z, net0, net1);
}
};
class GEN_AOI211_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b=X;
  VAL c=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X;
  AND (net0, a1, a2);
  OR (net1, net0, b, c);
  NOT (zn, net1);
}
static void function(VAL &a1,VAL &a2,VAL &b,VAL &c,VAL &zn){
  VAL net0=X, net1=X;
  AND (net0, a1, a2);
  OR (net1, net0, b, c);
  NOT (zn, net1);
}
};
class GEN_AOI211_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b=X;
  VAL c=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X;
  AND (net0, a1, a2);
  OR (net1, net0, b, c);
  NOT (zn, net1);
}
static void function(VAL &a1,VAL &a2,VAL &b,VAL &c,VAL &zn){
  VAL net0=X, net1=X;
  AND (net0, a1, a2);
  OR (net1, net0, b, c);
  NOT (zn, net1);
}
};
class GEN_AOI211_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b=X;
  VAL c=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X;
  AND (net0, a1, a2);
  OR (net1, net0, b, c);
  NOT (zn, net1);
}
static void function(VAL &a1,VAL &a2,VAL &b,VAL &c,VAL &zn){
  VAL net0=X, net1=X;
  AND (net0, a1, a2);
  OR (net1, net0, b, c);
  NOT (zn, net1);
}
};
class GEN_AOI21_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X;
  AND (net0, a1, a2);
  OR (net1, net0, b);
  NOT (zn, net1);
}
static void function(VAL &a1,VAL &a2,VAL &b,VAL &zn){
  VAL net0=X, net1=X;
  AND (net0, a1, a2);
  OR (net1, net0, b);
  NOT (zn, net1);
}
};
class GEN_AOI21_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X;
  AND (net0, a1, a2);
  OR (net1, net0, b);
  NOT (zn, net1);
}
static void function(VAL &a1,VAL &a2,VAL &b,VAL &zn){
  VAL net0=X, net1=X;
  AND (net0, a1, a2);
  OR (net1, net0, b);
  NOT (zn, net1);
}
};
class GEN_AOI21_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X;
  AND (net0, a1, a2);
  OR (net1, net0, b);
  NOT (zn, net1);
}
static void function(VAL &a1,VAL &a2,VAL &b,VAL &zn){
  VAL net0=X, net1=X;
  AND (net0, a1, a2);
  OR (net1, net0, b);
  NOT (zn, net1);
}
};
class GEN_AOI221_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b1=X;
  VAL b2=X;
  VAL c=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X, net2=X;
  AND (net0, a1, a2);
  AND (net1, b1, b2);
  OR (net2, net0, net1, c);
  NOT (zn, net2);
}
static void function(VAL &a1,VAL &a2,VAL &b1,VAL &b2,VAL &c,VAL &zn){
  VAL net0=X, net1=X, net2=X;
  AND (net0, a1, a2);
  AND (net1, b1, b2);
  OR (net2, net0, net1, c);
  NOT (zn, net2);
}
};
class GEN_AOI221_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b1=X;
  VAL b2=X;
  VAL c=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X, net2=X;
  AND (net0, a1, a2);
  AND (net1, b1, b2);
  OR (net2, net0, net1, c);
  NOT (zn, net2);
}
static void function(VAL &a1,VAL &a2,VAL &b1,VAL &b2,VAL &c,VAL &zn){
  VAL net0=X, net1=X, net2=X;
  AND (net0, a1, a2);
  AND (net1, b1, b2);
  OR (net2, net0, net1, c);
  NOT (zn, net2);
}
};
class GEN_AOI221_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b1=X;
  VAL b2=X;
  VAL c=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X, net2=X;
  AND (net0, a1, a2);
  AND (net1, b1, b2);
  OR (net2, net0, net1, c);
  NOT (zn, net2);
}
static void function(VAL &a1,VAL &a2,VAL &b1,VAL &b2,VAL &c,VAL &zn){
  VAL net0=X, net1=X, net2=X;
  AND (net0, a1, a2);
  AND (net1, b1, b2);
  OR (net2, net0, net1, c);
  NOT (zn, net2);
}
};
class GEN_AOI222_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b1=X;
  VAL b2=X;
  VAL c1=X;
  VAL c2=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X, net2=X, net3=X;
  AND (net0, c1, c2);
  AND (net1, a1, a2);
  AND (net2, b1, b2);
  OR (net3, net0, net1, net2);
  NOT (zn, net3);
}
static void function(VAL &a1,VAL &a2,VAL &b1,VAL &b2,VAL &c1,VAL &c2,VAL &zn){
  VAL net0=X, net1=X, net2=X, net3=X;
  AND (net0, c1, c2);
  AND (net1, a1, a2);
  AND (net2, b1, b2);
  OR (net3, net0, net1, net2);
  NOT (zn, net3);
}
};
class GEN_AOI222_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b1=X;
  VAL b2=X;
  VAL c1=X;
  VAL c2=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X, net2=X, net3=X;
  AND (net0, c1, c2);
  AND (net1, a1, a2);
  AND (net2, b1, b2);
  OR (net3, net0, net1, net2);
  NOT (zn, net3);
}
static void function(VAL &a1,VAL &a2,VAL &b1,VAL &b2,VAL &c1,VAL &c2,VAL &zn){
  VAL net0=X, net1=X, net2=X, net3=X;
  AND (net0, c1, c2);
  AND (net1, a1, a2);
  AND (net2, b1, b2);
  OR (net3, net0, net1, net2);
  NOT (zn, net3);
}
};
class GEN_AOI222_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b1=X;
  VAL b2=X;
  VAL c1=X;
  VAL c2=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X, net2=X, net3=X;
  AND (net0, c1, c2);
  AND (net1, a1, a2);
  AND (net2, b1, b2);
  OR (net3, net0, net1, net2);
  NOT (zn, net3);
}
static void function(VAL &a1,VAL &a2,VAL &b1,VAL &b2,VAL &c1,VAL &c2,VAL &zn){
  VAL net0=X, net1=X, net2=X, net3=X;
  AND (net0, c1, c2);
  AND (net1, a1, a2);
  AND (net2, b1, b2);
  OR (net3, net0, net1, net2);
  NOT (zn, net3);
}
};
class GEN_AOI22_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b1=X;
  VAL b2=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X, net2=X;
  AND (net0, a1, a2);
  AND (net1, b1, b2);
  OR (net2, net0, net1);
  NOT (zn, net2);
}
static void function(VAL &a1,VAL &a2,VAL &b1,VAL &b2,VAL &zn){
  VAL net0=X, net1=X, net2=X;
  AND (net0, a1, a2);
  AND (net1, b1, b2);
  OR (net2, net0, net1);
  NOT (zn, net2);
}
};
class GEN_AOI22_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b1=X;
  VAL b2=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X, net2=X;
  AND (net0, a1, a2);
  AND (net1, b1, b2);
  OR (net2, net0, net1);
  NOT (zn, net2);
}
static void function(VAL &a1,VAL &a2,VAL &b1,VAL &b2,VAL &zn){
  VAL net0=X, net1=X, net2=X;
  AND (net0, a1, a2);
  AND (net1, b1, b2);
  OR (net2, net0, net1);
  NOT (zn, net2);
}
};
class GEN_AOI22_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b1=X;
  VAL b2=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X, net2=X;
  AND (net0, a1, a2);
  AND (net1, b1, b2);
  OR (net2, net0, net1);
  NOT (zn, net2);
}
static void function(VAL &a1,VAL &a2,VAL &b1,VAL &b2,VAL &zn){
  VAL net0=X, net1=X, net2=X;
  AND (net0, a1, a2);
  AND (net1, b1, b2);
  OR (net2, net0, net1);
  NOT (zn, net2);
}
};
class GEN_AOI31_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL b=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X;
  AND (net0, a1, a2, a3);
  OR (net1, net0, b);
  NOT (zn, net1);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &b,VAL &zn){
  VAL net0=X, net1=X;
  AND (net0, a1, a2, a3);
  OR (net1, net0, b);
  NOT (zn, net1);
}
};
class GEN_AOI31_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL b=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X;
  AND (net0, a1, a2, a3);
  OR (net1, net0, b);
  NOT (zn, net1);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &b,VAL &zn){
  VAL net0=X, net1=X;
  AND (net0, a1, a2, a3);
  OR (net1, net0, b);
  NOT (zn, net1);
}
};
class GEN_AOI31_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL b=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X;
  AND (net0, a1, a2, a3);
  OR (net1, net0, b);
  NOT (zn, net1);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &b,VAL &zn){
  VAL net0=X, net1=X;
  AND (net0, a1, a2, a3);
  OR (net1, net0, b);
  NOT (zn, net1);
}
};
class GEN_AOI32_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL b1=X;
  VAL b2=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X, net2=X;
  AND (net0, a1, a2, a3);
  AND (net1, b1, b2);
  OR (net2, net0, net1);
  NOT (zn, net2);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &b1,VAL &b2,VAL &zn){
  VAL net0=X, net1=X, net2=X;
  AND (net0, a1, a2, a3);
  AND (net1, b1, b2);
  OR (net2, net0, net1);
  NOT (zn, net2);
}
};
class GEN_AOI32_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL b1=X;
  VAL b2=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X, net2=X;
  AND (net0, a1, a2, a3);
  AND (net1, b1, b2);
  OR (net2, net0, net1);
  NOT (zn, net2);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &b1,VAL &b2,VAL &zn){
  VAL net0=X, net1=X, net2=X;
  AND (net0, a1, a2, a3);
  AND (net1, b1, b2);
  OR (net2, net0, net1);
  NOT (zn, net2);
}
};
class GEN_AOI32_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL b1=X;
  VAL b2=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X, net2=X;
  AND (net0, a1, a2, a3);
  AND (net1, b1, b2);
  OR (net2, net0, net1);
  NOT (zn, net2);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &b1,VAL &b2,VAL &zn){
  VAL net0=X, net1=X, net2=X;
  AND (net0, a1, a2, a3);
  AND (net1, b1, b2);
  OR (net2, net0, net1);
  NOT (zn, net2);
}
};
class GEN_AOI33_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL b1=X;
  VAL b2=X;
  VAL b3=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X, net2=X;
  AND (net0, a1, a2, a3);
  AND (net1, b1, b2, b3);
  OR (net2, net0, net1);
  NOT (zn, net2);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &b1,VAL &b2,VAL &b3,VAL &zn){
  VAL net0=X, net1=X, net2=X;
  AND (net0, a1, a2, a3);
  AND (net1, b1, b2, b3);
  OR (net2, net0, net1);
  NOT (zn, net2);
}
};
class GEN_AOI33_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL b1=X;
  VAL b2=X;
  VAL b3=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X, net2=X;
  AND (net0, a1, a2, a3);
  AND (net1, b1, b2, b3);
  OR (net2, net0, net1);
  NOT (zn, net2);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &b1,VAL &b2,VAL &b3,VAL &zn){
  VAL net0=X, net1=X, net2=X;
  AND (net0, a1, a2, a3);
  AND (net1, b1, b2, b3);
  OR (net2, net0, net1);
  NOT (zn, net2);
}
};
class GEN_AOI33_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL b1=X;
  VAL b2=X;
  VAL b3=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X, net2=X;
  AND (net0, a1, a2, a3);
  AND (net1, b1, b2, b3);
  OR (net2, net0, net1);
  NOT (zn, net2);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &b1,VAL &b2,VAL &b3,VAL &zn){
  VAL net0=X, net1=X, net2=X;
  AND (net0, a1, a2, a3);
  AND (net1, b1, b2, b3);
  OR (net2, net0, net1);
  NOT (zn, net2);
}
};
class GEN_BUF_D1:GATE{
public:
  VAL i=X;
  VAL z=X;
VAL* pos()override{
 return &i;
}
void function()override{
  buf (z, i);
}
static void function(VAL &i,VAL &z){
  buf (z, i);
}
};
class GEN_BUF_D2:GATE{
public:
  VAL i=X;
  VAL z=X;
VAL* pos()override{
 return &i;
}
void function()override{
  buf (z, i);
}
static void function(VAL &i,VAL &z){
  buf (z, i);
}
};
class GEN_BUF_D4:GATE{
public:
  VAL i=X;
  VAL z=X;
VAL* pos()override{
 return &i;
}
void function()override{
  buf (z, i);
}
static void function(VAL &i,VAL &z){
  buf (z, i);
}
};
class GEN_BUF_D8:GATE{
public:
  VAL i=X;
  VAL z=X;
VAL* pos()override{
 return &i;
}
void function()override{
  buf (z, i);
}
static void function(VAL &i,VAL &z){
  buf (z, i);
}
};
class GEN_FA_D1:GATE{
public:
  VAL a=X;
  VAL b=X;
  VAL ci=X;
  VAL s=X;
  VAL co=X;
VAL* pos()override{
 return &a;
}
void function()override{
  VAL net0=X, net1=X, net2=X;
  XOR (s, a, b, ci);
  AND (net0, a, b);
  AND (net1, a, ci);
  AND (net2, b, ci);
  OR (co, net0, net1, net2);
}
static void function(VAL &a,VAL &b,VAL &ci,VAL &s,VAL &co){
  VAL net0=X, net1=X, net2=X;
  XOR (s, a, b, ci);
  AND (net0, a, b);
  AND (net1, a, ci);
  AND (net2, b, ci);
  OR (co, net0, net1, net2);
}
};
class GEN_FA_D2:GATE{
public:
  VAL a=X;
  VAL b=X;
  VAL ci=X;
  VAL s=X;
  VAL co=X;
VAL* pos()override{
 return &a;
}
void function()override{
  VAL net0=X, net1=X, net2=X;
  XOR (s, a, b, ci);
  AND (net0, a, b);
  AND (net1, a, ci);
  AND (net2, b, ci);
  OR (co, net0, net1, net2);
}
static void function(VAL &a,VAL &b,VAL &ci,VAL &s,VAL &co){
  VAL net0=X, net1=X, net2=X;
  XOR (s, a, b, ci);
  AND (net0, a, b);
  AND (net1, a, ci);
  AND (net2, b, ci);
  OR (co, net0, net1, net2);
}
};
class GEN_FA_D4:GATE{
public:
  VAL a=X;
  VAL b=X;
  VAL ci=X;
  VAL s=X;
  VAL co=X;
VAL* pos()override{
 return &a;
}
void function()override{
  VAL net0=X, net1=X, net2=X;
  XOR (s, a, b, ci);
  AND (net0, a, b);
  AND (net1, a, ci);
  AND (net2, b, ci);
  OR (co, net0, net1, net2);
}
static void function(VAL &a,VAL &b,VAL &ci,VAL &s,VAL &co){
  VAL net0=X, net1=X, net2=X;
  XOR (s, a, b, ci);
  AND (net0, a, b);
  AND (net1, a, ci);
  AND (net2, b, ci);
  OR (co, net0, net1, net2);
}
};
class GEN_HA_D1:GATE{
public:
  VAL a=X;
  VAL b=X;
  VAL s=X;
  VAL co=X;
VAL* pos()override{
 return &a;
}
void function()override{
  XOR (s, a, b);
  AND (co, a, b);
}
static void function(VAL &a,VAL &b,VAL &s,VAL &co){
  XOR (s, a, b);
  AND (co, a, b);
}
};
class GEN_HA_D2:GATE{
public:
  VAL a=X;
  VAL b=X;
  VAL s=X;
  VAL co=X;
VAL* pos()override{
 return &a;
}
void function()override{
  XOR (s, a, b);
  AND (co, a, b);
}
static void function(VAL &a,VAL &b,VAL &s,VAL &co){
  XOR (s, a, b);
  AND (co, a, b);
}
};
class GEN_HA_D4:GATE{
public:
  VAL a=X;
  VAL b=X;
  VAL s=X;
  VAL co=X;
VAL* pos()override{
 return &a;
}
void function()override{
  XOR (s, a, b);
  AND (co, a, b);
}
static void function(VAL &a,VAL &b,VAL &s,VAL &co){
  XOR (s, a, b);
  AND (co, a, b);
}
};
class GEN_INV_D1:GATE{
public:
  VAL i=X;
  VAL zn=X;
VAL* pos()override{
 return &i;
}
void function()override{
  NOT (zn, i);
}
static void function(VAL &i,VAL &zn){
  NOT (zn, i);
}
};
class GEN_INV_D2:GATE{
public:
  VAL i=X;
  VAL zn=X;
VAL* pos()override{
 return &i;
}
void function()override{
  NOT (zn, i);
}
static void function(VAL &i,VAL &zn){
  NOT (zn, i);
}
};
class GEN_INV_D4:GATE{
public:
  VAL i=X;
  VAL zn=X;
VAL* pos()override{
 return &i;
}
void function()override{
  NOT (zn, i);
}
static void function(VAL &i,VAL &zn){
  NOT (zn, i);
}
};
class GEN_INV_D8:GATE{
public:
  VAL i=X;
  VAL zn=X;
VAL* pos()override{
 return &i;
}
void function()override{
  NOT (zn, i);
}
static void function(VAL &i,VAL &zn){
  NOT (zn, i);
}
};
class GEN_MAJORITYAOI222_D1:GATE{
public:
  VAL a=X;
  VAL b=X;
  VAL c=X;
  VAL zn=X;
VAL* pos()override{
 return &a;
}
void function()override{
  VAL net0=X, net1=X, net2=X, net3=X;
  AND (net0, a, b);
  AND (net1, b, c);
  AND (net2, c, a);
  OR (net3, net0, net1, net2);
  NOT (zn, net3);
}
static void function(VAL &a,VAL &b,VAL &c,VAL &zn){
  VAL net0=X, net1=X, net2=X, net3=X;
  AND (net0, a, b);
  AND (net1, b, c);
  AND (net2, c, a);
  OR (net3, net0, net1, net2);
  NOT (zn, net3);
}
};
class GEN_MAJORITYAOI222_D2:GATE{
public:
  VAL a=X;
  VAL b=X;
  VAL c=X;
  VAL zn=X;
VAL* pos()override{
 return &a;
}
void function()override{
  VAL net0=X, net1=X, net2=X, net3=X;
  AND (net0, a, b);
  AND (net1, b, c);
  AND (net2, c, a);
  OR (net3, net0, net1, net2);
  NOT (zn, net3);
}
static void function(VAL &a,VAL &b,VAL &c,VAL &zn){
  VAL net0=X, net1=X, net2=X, net3=X;
  AND (net0, a, b);
  AND (net1, b, c);
  AND (net2, c, a);
  OR (net3, net0, net1, net2);
  NOT (zn, net3);
}
};
class GEN_MAJORITYAOI222_D4:GATE{
public:
  VAL a=X;
  VAL b=X;
  VAL c=X;
  VAL zn=X;
VAL* pos()override{
 return &a;
}
void function()override{
  VAL net0=X, net1=X, net2=X, net3=X;
  AND (net0, a, b);
  AND (net1, b, c);
  AND (net2, c, a);
  OR (net3, net0, net1, net2);
  NOT (zn, net3);
}
static void function(VAL &a,VAL &b,VAL &c,VAL &zn){
  VAL net0=X, net1=X, net2=X, net3=X;
  AND (net0, a, b);
  AND (net1, b, c);
  AND (net2, c, a);
  OR (net3, net0, net1, net2);
  NOT (zn, net3);
}
};
class GEN_MAJORITYAOI22_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b1=X;
  VAL b2=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X, net2=X;
  AND (net0, a1, a2);
  NOT (net1, net0);
  OR (net2, b1, b2);
  AND (zn, net1, net2);
}
static void function(VAL &a1,VAL &a2,VAL &b1,VAL &b2,VAL &zn){
  VAL net0=X, net1=X, net2=X;
  AND (net0, a1, a2);
  NOT (net1, net0);
  OR (net2, b1, b2);
  AND (zn, net1, net2);
}
};
class GEN_MAJORITYAOI22_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b1=X;
  VAL b2=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X, net2=X;
  AND (net0, a1, a2);
  NOT (net1, net0);
  OR (net2, b1, b2);
  AND (zn, net1, net2);
}
static void function(VAL &a1,VAL &a2,VAL &b1,VAL &b2,VAL &zn){
  VAL net0=X, net1=X, net2=X;
  AND (net0, a1, a2);
  NOT (net1, net0);
  OR (net2, b1, b2);
  AND (zn, net1, net2);
}
};
class GEN_MAJORITYAOI22_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b1=X;
  VAL b2=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X, net2=X;
  AND (net0, a1, a2);
  NOT (net1, net0);
  OR (net2, b1, b2);
  AND (zn, net1, net2);
}
static void function(VAL &a1,VAL &a2,VAL &b1,VAL &b2,VAL &zn){
  VAL net0=X, net1=X, net2=X;
  AND (net0, a1, a2);
  NOT (net1, net0);
  OR (net2, b1, b2);
  AND (zn, net1, net2);
}
};
class GEN_MAJORITYOAI22_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b1=X;
  VAL b2=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X, net2=X;
  OR  (net0, a1, a2);
  NOT (net1, net0);
  AND (net2, b1, b2);
  OR (zn, net1, net2);
}
static void function(VAL &a1,VAL &a2,VAL &b1,VAL &b2,VAL &zn){
  VAL net0=X, net1=X, net2=X;
  OR  (net0, a1, a2);
  NOT (net1, net0);
  AND (net2, b1, b2);
  OR (zn, net1, net2);
}
};
class GEN_MAJORITYOAI22_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b1=X;
  VAL b2=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X, net2=X;
  OR  (net0, a1, a2);
  NOT (net1, net0);
  AND (net2, b1, b2);
  OR (zn, net1, net2);
}
static void function(VAL &a1,VAL &a2,VAL &b1,VAL &b2,VAL &zn){
  VAL net0=X, net1=X, net2=X;
  OR  (net0, a1, a2);
  NOT (net1, net0);
  AND (net2, b1, b2);
  OR (zn, net1, net2);
}
};
class GEN_MAJORITYOAI22_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b1=X;
  VAL b2=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X, net2=X;
  OR  (net0, a1, a2);
  NOT (net1, net0);
  AND (net2, b1, b2);
  OR (zn, net1, net2);
}
static void function(VAL &a1,VAL &a2,VAL &b1,VAL &b2,VAL &zn){
  VAL net0=X, net1=X, net2=X;
  OR  (net0, a1, a2);
  NOT (net1, net0);
  AND (net2, b1, b2);
  OR (zn, net1, net2);
}
};
class GEN_LATCH_D1:GATE{
public:
  VAL d=X;
  VAL e=X;
  VAL q=X;
  VAL notifier=X;
udp_tlat udpi0;
VAL* pos()override{
 return &d;
}
void function()override{
  VAL cdn=I;
  VAL sdn=I;
  udpi0.function(q, d, e, cdn, sdn, notifier);
}
};
class GEN_LATCH_D2:GATE{
public:
  VAL d=X;
  VAL e=X;
  VAL q=X;
  VAL notifier=X;
udp_tlat udpi0;
VAL* pos()override{
 return &d;
}
void function()override{
  VAL cdn=I;
  VAL sdn=I;
  udpi0.function(q, d, e, cdn, sdn, notifier);
}
};
class GEN_LATCH_D4:GATE{
public:
  VAL d=X;
  VAL e=X;
  VAL q=X;
  VAL notifier=X;
udp_tlat udpi0;
VAL* pos()override{
 return &d;
}
void function()override{
  VAL cdn=I;
  VAL sdn=I;
  udpi0.function(q, d, e, cdn, sdn, notifier);
}
};
class GEN_DFCLR_D1:GATE{
public:
  VAL d=X;
  VAL cp=X;
  VAL cdn=X;
  VAL q=X;
  VAL notifier=X;
udp_dff udpi0;
VAL* pos()override{
 return &d;
}
void function()override{
  VAL sdn=I;
  udpi0.function(q, d, cp, cdn, sdn, notifier);
}
};
class GEN_DFCLR_D2:GATE{
public:
  VAL d=X;
  VAL cp=X;
  VAL cdn=X;
  VAL q=X;
  VAL notifier=X;
udp_dff udpi0;
VAL* pos()override{
 return &d;
}
void function()override{
  VAL sdn=I;
  udpi0.function(q, d, cp, cdn, sdn, notifier);
}
};
class GEN_DFCLR_D4:GATE{
public:
  VAL d=X;
  VAL cp=X;
  VAL cdn=X;
  VAL q=X;
  VAL notifier=X;
udp_dff udpi0;
VAL* pos()override{
 return &d;
}
void function()override{
  VAL sdn=I;
  udpi0.function(q, d, cp, cdn, sdn, notifier);
}
};
class GEN_DFCLR_D8:GATE{
public:
  VAL d=X;
  VAL cp=X;
  VAL cdn=X;
  VAL q=X;
  VAL notifier=X;
udp_dff udpi0;
VAL* pos()override{
 return &d;
}
void function()override{
  VAL sdn=I;
  udpi0.function(q, d, cp, cdn, sdn, notifier);
}
};
class GEN_DF_D1:GATE{
public:
  VAL d=X;
  VAL cp=X;
  VAL q=X;
  VAL notifier=X;
udp_dff udpi0;
VAL* pos()override{
 return &d;
}
void function()override{
  VAL cdn=I;
  VAL sdn=I;
  udpi0.function(q, d, cp, cdn, sdn, notifier);
}
};
class GEN_DF_D2:GATE{
public:
  VAL d=X;
  VAL cp=X;
  VAL q=X;
  VAL notifier=X;
udp_dff udpi0;
VAL* pos()override{
 return &d;
}
void function()override{
  VAL cdn=I;
  VAL sdn=I;
  udpi0.function(q, d, cp, cdn, sdn, notifier);
}
};
class GEN_DF_D4:GATE{
public:
  VAL d=X;
  VAL cp=X;
  VAL q=X;
  VAL notifier=X;
udp_dff udpi0;
VAL* pos()override{
 return &d;
}
void function()override{
  VAL cdn=I;
  VAL sdn=I;
  udpi0.function(q, d, cp, cdn, sdn, notifier);
}
};
class GEN_DF_D8:GATE{
public:
  VAL d=X;
  VAL cp=X;
  VAL q=X;
  VAL notifier=X;
udp_dff udpi0;
VAL* pos()override{
 return &d;
}
void function()override{
  VAL cdn=I;
  VAL sdn=I;
  udpi0.function(q, d, cp, cdn, sdn, notifier);
}
};
class GEN_DFSET_D1:GATE{
public:
  VAL d=X;
  VAL cp=X;
  VAL sdn=X;
  VAL q=X;
  VAL notifier=X;
udp_dff udpi0;
VAL* pos()override{
 return &d;
}
void function()override{
  VAL cdn=I;
  udpi0.function(q, d, cp, cdn, sdn, notifier);
}
};
class GEN_DFSET_D2:GATE{
public:
  VAL d=X;
  VAL cp=X;
  VAL sdn=X;
  VAL q=X;
  VAL notifier=X;
udp_dff udpi0;
VAL* pos()override{
 return &d;
}
void function()override{
  VAL cdn=I;
  udpi0.function(q, d, cp, cdn, sdn, notifier);
}
};
class GEN_DFSET_D4:GATE{
public:
  VAL d=X;
  VAL cp=X;
  VAL sdn=X;
  VAL q=X;
  VAL notifier=X;
udp_dff udpi0;
VAL* pos()override{
 return &d;
}
void function()override{
  VAL cdn=I;
  udpi0.function(q, d, cp, cdn, sdn, notifier);
}
};
class GEN_DFSET_D8:GATE{
public:
  VAL d=X;
  VAL cp=X;
  VAL sdn=X;
  VAL q=X;
  VAL notifier=X;
udp_dff udpi0;
VAL* pos()override{
 return &d;
}
void function()override{
  VAL cdn=I;
  udpi0.function(q, d, cp, cdn, sdn, notifier);
}
};
class GEN_MUX2_D1:GATE{
public:
  VAL i0=X;
  VAL i1=X;
  VAL s=X;
  VAL z=X;
udp_mux2 udpi0;
VAL* pos()override{
 return &i0;
}
void function()override{
  udpi0.function(z, i0, i1, s);
}
};
class GEN_MUX2_D2:GATE{
public:
  VAL i0=X;
  VAL i1=X;
  VAL s=X;
  VAL z=X;
udp_mux2 udpi0;
VAL* pos()override{
 return &i0;
}
void function()override{
  udpi0.function(z, i0, i1, s);
}
};
class GEN_MUX2_D4:GATE{
public:
  VAL i0=X;
  VAL i1=X;
  VAL s=X;
  VAL z=X;
udp_mux2 udpi0;
VAL* pos()override{
 return &i0;
}
void function()override{
  udpi0.function(z, i0, i1, s);
}
};
class GEN_MUX2N_D1:GATE{
public:
  VAL i0=X;
  VAL i1=X;
  VAL s=X;
  VAL zn=X;
udp_mux2 udpi0;
VAL* pos()override{
 return &i0;
}
void function()override{
  VAL z=X;
  udpi0.function(z, i0, i1, s);
  NOT (zn, z);
}
};
class GEN_MUX2N_D2:GATE{
public:
  VAL i0=X;
  VAL i1=X;
  VAL s=X;
  VAL zn=X;
udp_mux2 udpi0;
VAL* pos()override{
 return &i0;
}
void function()override{
  VAL z=X;
  udpi0.function(z, i0, i1, s);
  NOT (zn, z);
}
};
class GEN_MUX2N_D4:GATE{
public:
  VAL i0=X;
  VAL i1=X;
  VAL s=X;
  VAL zn=X;
udp_mux2 udpi0;
VAL* pos()override{
 return &i0;
}
void function()override{
  VAL z=X;
  udpi0.function(z, i0, i1, s);
  NOT (zn, z);
}
};
class GEN_MUX3_D1:GATE{
public:
  VAL i0=X;
  VAL i1=X;
  VAL i2=X;
  VAL s0=X;
  VAL s1=X;
  VAL z=X;
udp_mux2 udpi0;
udp_mux2 udpi1;
VAL* pos()override{
 return &i0;
}
void function()override{
  VAL net0=X;
  udpi0.function(net0, i0, i1, s0);
  udpi1.function(z, net0, i2, s1);
}
};
class GEN_MUX3_D2:GATE{
public:
  VAL i0=X;
  VAL i1=X;
  VAL i2=X;
  VAL s0=X;
  VAL s1=X;
  VAL z=X;
udp_mux2 udpi0;
udp_mux2 udpi1;
VAL* pos()override{
 return &i0;
}
void function()override{
  VAL net0=X;
  udpi0.function(net0, i0, i1, s0);
  udpi1.function(z, net0, i2, s1);
}
};
class GEN_MUX3_D4:GATE{
public:
  VAL i0=X;
  VAL i1=X;
  VAL i2=X;
  VAL s0=X;
  VAL s1=X;
  VAL z=X;
udp_mux2 udpi0;
udp_mux2 udpi1;
VAL* pos()override{
 return &i0;
}
void function()override{
  VAL net0=X;
  udpi0.function(net0, i0, i1, s0);
  udpi1.function(z, net0, i2, s1);
}
};
class GEN_MUX3N_D1:GATE{
public:
  VAL i0=X;
  VAL i1=X;
  VAL i2=X;
  VAL s0=X;
  VAL s1=X;
  VAL zn=X;
udp_mux2 udpi0;
udp_mux2 udpi1;
VAL* pos()override{
 return &i0;
}
void function()override{
  VAL net0=X, net1=X;
  udpi0.function(net0, i0, i1, s0);
  udpi1.function(net1, net0, i2, s1);
  NOT (zn, net1);
}
};
class GEN_MUX3N_D2:GATE{
public:
  VAL i0=X;
  VAL i1=X;
  VAL i2=X;
  VAL s0=X;
  VAL s1=X;
  VAL zn=X;
udp_mux2 udpi0;
udp_mux2 udpi1;
VAL* pos()override{
 return &i0;
}
void function()override{
  VAL net0=X, net1=X;
  udpi0.function(net0, i0, i1, s0);
  udpi1.function(net1, net0, i2, s1);
  NOT (zn, net1);
}
};
class GEN_MUX3N_D4:GATE{
public:
  VAL i0=X;
  VAL i1=X;
  VAL i2=X;
  VAL s0=X;
  VAL s1=X;
  VAL zn=X;
udp_mux2 udpi0;
udp_mux2 udpi1;
VAL* pos()override{
 return &i0;
}
void function()override{
  VAL net0=X, net1=X;
  udpi0.function(net0, i0, i1, s0);
  udpi1.function(net1, net0, i2, s1);
  NOT (zn, net1);
}
};
class GEN_MUX4_D1:GATE{
public:
  VAL i0=X;
  VAL i1=X;
  VAL i2=X;
  VAL i3=X;
  VAL s0=X;
  VAL s1=X;
  VAL z=X;
udp_mux2 udpi0;
udp_mux2 udpi1;
udp_mux2 udpi2;
VAL* pos()override{
 return &i0;
}
void function()override{
  VAL net0=X, net1=X;
  udpi0.function(net0, i2, i3, s0);
  udpi1.function(net1, i0, i1, s0);
  udpi2.function(z, net1, net0, s1);
}
};
class GEN_MUX4_D2:GATE{
public:
  VAL i0=X;
  VAL i1=X;
  VAL i2=X;
  VAL i3=X;
  VAL s0=X;
  VAL s1=X;
  VAL z=X;
udp_mux2 udpi0;
udp_mux2 udpi1;
udp_mux2 udpi2;
VAL* pos()override{
 return &i0;
}
void function()override{
  VAL net0=X, net1=X;
  udpi0.function(net0, i2, i3, s0);
  udpi1.function(net1, i0, i1, s0);
  udpi2.function(z, net1, net0, s1);
}
};
class GEN_MUX4_D4:GATE{
public:
  VAL i0=X;
  VAL i1=X;
  VAL i2=X;
  VAL i3=X;
  VAL s0=X;
  VAL s1=X;
  VAL z=X;
udp_mux2 udpi0;
udp_mux2 udpi1;
udp_mux2 udpi2;
VAL* pos()override{
 return &i0;
}
void function()override{
  VAL net0=X, net1=X;
  udpi0.function(net0, i2, i3, s0);
  udpi1.function(net1, i0, i1, s0);
  udpi2.function(z, net1, net0, s1);
}
};
class GEN_MUX4N_D1:GATE{
public:
  VAL i0=X;
  VAL i1=X;
  VAL i2=X;
  VAL i3=X;
  VAL s0=X;
  VAL s1=X;
  VAL zn=X;
udp_mux2 udpi0;
udp_mux2 udpi1;
udp_mux2 udpi2;
VAL* pos()override{
 return &i0;
}
void function()override{
  VAL net0=X, net1=X, net2=X;
  udpi0.function(net0, i2, i3, s0);
  udpi1.function(net1, i0, i1, s0);
  udpi2.function(net2, net1, net0, s1);
  NOT (zn, net2);
}
};
class GEN_MUX4N_D2:GATE{
public:
  VAL i0=X;
  VAL i1=X;
  VAL i2=X;
  VAL i3=X;
  VAL s0=X;
  VAL s1=X;
  VAL zn=X;
udp_mux2 udpi0;
udp_mux2 udpi1;
udp_mux2 udpi2;
VAL* pos()override{
 return &i0;
}
void function()override{
  VAL net0=X, net1=X, net2=X;
  udpi0.function(net0, i2, i3, s0);
  udpi1.function(net1, i0, i1, s0);
  udpi2.function(net2, net1, net0, s1);
  NOT (zn, net2);
}
};
class GEN_MUX4N_D4:GATE{
public:
  VAL i0=X;
  VAL i1=X;
  VAL i2=X;
  VAL i3=X;
  VAL s0=X;
  VAL s1=X;
  VAL zn=X;
udp_mux2 udpi0;
udp_mux2 udpi1;
udp_mux2 udpi2;
VAL* pos()override{
 return &i0;
}
void function()override{
  VAL net0=X, net1=X, net2=X;
  udpi0.function(net0, i2, i3, s0);
  udpi1.function(net1, i0, i1, s0);
  udpi2.function(net2, net1, net0, s1);
  NOT (zn, net2);
}
};
class GEN_NAND2_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  NAND (zn, a1, a2);
}
static void function(VAL &a1,VAL &a2,VAL &zn){
  NAND (zn, a1, a2);
}
};
class GEN_NAND2_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  NAND (zn, a1, a2);
}
static void function(VAL &a1,VAL &a2,VAL &zn){
  NAND (zn, a1, a2);
}
};
class GEN_NAND2_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  NAND (zn, a1, a2);
}
static void function(VAL &a1,VAL &a2,VAL &zn){
  NAND (zn, a1, a2);
}
};
class GEN_NAND2_D8:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  NAND (zn, a1, a2);
}
static void function(VAL &a1,VAL &a2,VAL &zn){
  NAND (zn, a1, a2);
}
};
class GEN_NAND3_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  NAND (zn, a1, a2, a3);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &zn){
  NAND (zn, a1, a2, a3);
}
};
class GEN_NAND3_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  NAND (zn, a1, a2, a3);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &zn){
  NAND (zn, a1, a2, a3);
}
};
class GEN_NAND3_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  NAND (zn, a1, a2, a3);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &zn){
  NAND (zn, a1, a2, a3);
}
};
class GEN_NAND3_D8:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  NAND (zn, a1, a2, a3);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &zn){
  NAND (zn, a1, a2, a3);
}
};
class GEN_NAND4_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL a4=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  NAND (zn, a1, a2, a3, a4);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &a4,VAL &zn){
  NAND (zn, a1, a2, a3, a4);
}
};
class GEN_NAND4_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL a4=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  NAND (zn, a1, a2, a3, a4);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &a4,VAL &zn){
  NAND (zn, a1, a2, a3, a4);
}
};
class GEN_NAND4_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL a4=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  NAND (zn, a1, a2, a3, a4);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &a4,VAL &zn){
  NAND (zn, a1, a2, a3, a4);
}
};
class GEN_NAND4_D8:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL a4=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  NAND (zn, a1, a2, a3, a4);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &a4,VAL &zn){
  NAND (zn, a1, a2, a3, a4);
}
};
class GEN_NOR2_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  NOR (zn, a1, a2);
}
static void function(VAL &a1,VAL &a2,VAL &zn){
  NOR (zn, a1, a2);
}
};
class GEN_NOR2_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  NOR (zn, a1, a2);
}
static void function(VAL &a1,VAL &a2,VAL &zn){
  NOR (zn, a1, a2);
}
};
class GEN_NOR2_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  NOR (zn, a1, a2);
}
static void function(VAL &a1,VAL &a2,VAL &zn){
  NOR (zn, a1, a2);
}
};
class GEN_NOR2_D8:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  NOR (zn, a1, a2);
}
static void function(VAL &a1,VAL &a2,VAL &zn){
  NOR (zn, a1, a2);
}
};
class GEN_NOR3_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  NOR (zn, a1, a2, a3);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &zn){
  NOR (zn, a1, a2, a3);
}
};
class GEN_NOR3_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  NOR (zn, a1, a2, a3);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &zn){
  NOR (zn, a1, a2, a3);
}
};
class GEN_NOR3_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  NOR (zn, a1, a2, a3);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &zn){
  NOR (zn, a1, a2, a3);
}
};
class GEN_NOR3_D8:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  NOR (zn, a1, a2, a3);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &zn){
  NOR (zn, a1, a2, a3);
}
};
class GEN_NOR4_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL a4=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  NOR (zn, a1, a2, a3, a4);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &a4,VAL &zn){
  NOR (zn, a1, a2, a3, a4);
}
};
class GEN_NOR4_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL a4=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  NOR (zn, a1, a2, a3, a4);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &a4,VAL &zn){
  NOR (zn, a1, a2, a3, a4);
}
};
class GEN_NOR4_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL a4=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  NOR (zn, a1, a2, a3, a4);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &a4,VAL &zn){
  NOR (zn, a1, a2, a3, a4);
}
};
class GEN_NOR4_D8:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL a4=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  NOR (zn, a1, a2, a3, a4);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &a4,VAL &zn){
  NOR (zn, a1, a2, a3, a4);
}
};
class GEN_OA211_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b=X;
  VAL c=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X;
  OR (net0, a1, a2);
  AND (z, net0, b, c);
}
static void function(VAL &a1,VAL &a2,VAL &b,VAL &c,VAL &z){
  VAL net0=X;
  OR (net0, a1, a2);
  AND (z, net0, b, c);
}
};
class GEN_OA211_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b=X;
  VAL c=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X;
  OR (net0, a1, a2);
  AND (z, net0, b, c);
}
static void function(VAL &a1,VAL &a2,VAL &b,VAL &c,VAL &z){
  VAL net0=X;
  OR (net0, a1, a2);
  AND (z, net0, b, c);
}
};
class GEN_OA211_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b=X;
  VAL c=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X;
  OR (net0, a1, a2);
  AND (z, net0, b, c);
}
static void function(VAL &a1,VAL &a2,VAL &b,VAL &c,VAL &z){
  VAL net0=X;
  OR (net0, a1, a2);
  AND (z, net0, b, c);
}
};
class GEN_OA21_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X;
  OR (net0, a1, a2);
  AND (z, net0, b);
}
static void function(VAL &a1,VAL &a2,VAL &b,VAL &z){
  VAL net0=X;
  OR (net0, a1, a2);
  AND (z, net0, b);
}
};
class GEN_OA21_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X;
  OR (net0, a1, a2);
  AND (z, net0, b);
}
static void function(VAL &a1,VAL &a2,VAL &b,VAL &z){
  VAL net0=X;
  OR (net0, a1, a2);
  AND (z, net0, b);
}
};
class GEN_OA21_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X;
  OR (net0, a1, a2);
  AND (z, net0, b);
}
static void function(VAL &a1,VAL &a2,VAL &b,VAL &z){
  VAL net0=X;
  OR (net0, a1, a2);
  AND (z, net0, b);
}
};
class GEN_OA221_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b1=X;
  VAL b2=X;
  VAL c=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X;
  OR (net0, b1, b2);
  OR (net1, a1, a2);
  AND (z, net0, net1, c);
}
static void function(VAL &a1,VAL &a2,VAL &b1,VAL &b2,VAL &c,VAL &z){
  VAL net0=X, net1=X;
  OR (net0, b1, b2);
  OR (net1, a1, a2);
  AND (z, net0, net1, c);
}
};
class GEN_OA221_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b1=X;
  VAL b2=X;
  VAL c=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X;
  OR (net0, b1, b2);
  OR (net1, a1, a2);
  AND (z, net0, net1, c);
}
static void function(VAL &a1,VAL &a2,VAL &b1,VAL &b2,VAL &c,VAL &z){
  VAL net0=X, net1=X;
  OR (net0, b1, b2);
  OR (net1, a1, a2);
  AND (z, net0, net1, c);
}
};
class GEN_OA221_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b1=X;
  VAL b2=X;
  VAL c=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X;
  OR (net0, b1, b2);
  OR (net1, a1, a2);
  AND (z, net0, net1, c);
}
static void function(VAL &a1,VAL &a2,VAL &b1,VAL &b2,VAL &c,VAL &z){
  VAL net0=X, net1=X;
  OR (net0, b1, b2);
  OR (net1, a1, a2);
  AND (z, net0, net1, c);
}
};
class GEN_OA222_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b1=X;
  VAL b2=X;
  VAL c1=X;
  VAL c2=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X, net2=X;
  OR (net0, a1, a2);
  OR (net1, c1, c2);
  OR (net2, b1, b2);
  AND (z, net0, net1, net2);
}
static void function(VAL &a1,VAL &a2,VAL &b1,VAL &b2,VAL &c1,VAL &c2,VAL &z){
  VAL net0=X, net1=X, net2=X;
  OR (net0, a1, a2);
  OR (net1, c1, c2);
  OR (net2, b1, b2);
  AND (z, net0, net1, net2);
}
};
class GEN_OA222_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b1=X;
  VAL b2=X;
  VAL c1=X;
  VAL c2=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X, net2=X;
  OR (net0, a1, a2);
  OR (net1, c1, c2);
  OR (net2, b1, b2);
  AND (z, net0, net1, net2);
}
static void function(VAL &a1,VAL &a2,VAL &b1,VAL &b2,VAL &c1,VAL &c2,VAL &z){
  VAL net0=X, net1=X, net2=X;
  OR (net0, a1, a2);
  OR (net1, c1, c2);
  OR (net2, b1, b2);
  AND (z, net0, net1, net2);
}
};
class GEN_OA222_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b1=X;
  VAL b2=X;
  VAL c1=X;
  VAL c2=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X, net2=X;
  OR (net0, a1, a2);
  OR (net1, c1, c2);
  OR (net2, b1, b2);
  AND (z, net0, net1, net2);
}
static void function(VAL &a1,VAL &a2,VAL &b1,VAL &b2,VAL &c1,VAL &c2,VAL &z){
  VAL net0=X, net1=X, net2=X;
  OR (net0, a1, a2);
  OR (net1, c1, c2);
  OR (net2, b1, b2);
  AND (z, net0, net1, net2);
}
};
class GEN_OA22_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b1=X;
  VAL b2=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X;
  OR (net0, b1, b2);
  OR (net1, a1, a2);
  AND (z, net0, net1);
}
static void function(VAL &a1,VAL &a2,VAL &b1,VAL &b2,VAL &z){
  VAL net0=X, net1=X;
  OR (net0, b1, b2);
  OR (net1, a1, a2);
  AND (z, net0, net1);
}
};
class GEN_OA22_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b1=X;
  VAL b2=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X;
  OR (net0, b1, b2);
  OR (net1, a1, a2);
  AND (z, net0, net1);
}
static void function(VAL &a1,VAL &a2,VAL &b1,VAL &b2,VAL &z){
  VAL net0=X, net1=X;
  OR (net0, b1, b2);
  OR (net1, a1, a2);
  AND (z, net0, net1);
}
};
class GEN_OA22_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b1=X;
  VAL b2=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X;
  OR (net0, b1, b2);
  OR (net1, a1, a2);
  AND (z, net0, net1);
}
static void function(VAL &a1,VAL &a2,VAL &b1,VAL &b2,VAL &z){
  VAL net0=X, net1=X;
  OR (net0, b1, b2);
  OR (net1, a1, a2);
  AND (z, net0, net1);
}
};
class GEN_OA31_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL b=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X;
  OR (net0, a1, a2, a3);
  AND (z, net0, b);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &b,VAL &z){
  VAL net0=X;
  OR (net0, a1, a2, a3);
  AND (z, net0, b);
}
};
class GEN_OA31_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL b=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X;
  OR (net0, a1, a2, a3);
  AND (z, net0, b);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &b,VAL &z){
  VAL net0=X;
  OR (net0, a1, a2, a3);
  AND (z, net0, b);
}
};
class GEN_OA31_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL b=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X;
  OR (net0, a1, a2, a3);
  AND (z, net0, b);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &b,VAL &z){
  VAL net0=X;
  OR (net0, a1, a2, a3);
  AND (z, net0, b);
}
};
class GEN_OA32_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL b1=X;
  VAL b2=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X;
  OR (net0, b1, b2);
  OR (net1, a1, a2, a3);
  AND (z, net0, net1);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &b1,VAL &b2,VAL &z){
  VAL net0=X, net1=X;
  OR (net0, b1, b2);
  OR (net1, a1, a2, a3);
  AND (z, net0, net1);
}
};
class GEN_OA32_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL b1=X;
  VAL b2=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X;
  OR (net0, b1, b2);
  OR (net1, a1, a2, a3);
  AND (z, net0, net1);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &b1,VAL &b2,VAL &z){
  VAL net0=X, net1=X;
  OR (net0, b1, b2);
  OR (net1, a1, a2, a3);
  AND (z, net0, net1);
}
};
class GEN_OA32_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL b1=X;
  VAL b2=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X;
  OR (net0, b1, b2);
  OR (net1, a1, a2, a3);
  AND (z, net0, net1);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &b1,VAL &b2,VAL &z){
  VAL net0=X, net1=X;
  OR (net0, b1, b2);
  OR (net1, a1, a2, a3);
  AND (z, net0, net1);
}
};
class GEN_OA33_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL b1=X;
  VAL b2=X;
  VAL b3=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X;
  OR (net0, b1, b2, b3);
  OR (net1, a1, a2, a3);
  AND (z, net0, net1);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &b1,VAL &b2,VAL &b3,VAL &z){
  VAL net0=X, net1=X;
  OR (net0, b1, b2, b3);
  OR (net1, a1, a2, a3);
  AND (z, net0, net1);
}
};
class GEN_OA33_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL b1=X;
  VAL b2=X;
  VAL b3=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X;
  OR (net0, b1, b2, b3);
  OR (net1, a1, a2, a3);
  AND (z, net0, net1);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &b1,VAL &b2,VAL &b3,VAL &z){
  VAL net0=X, net1=X;
  OR (net0, b1, b2, b3);
  OR (net1, a1, a2, a3);
  AND (z, net0, net1);
}
};
class GEN_OA33_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL b1=X;
  VAL b2=X;
  VAL b3=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X;
  OR (net0, b1, b2, b3);
  OR (net1, a1, a2, a3);
  AND (z, net0, net1);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &b1,VAL &b2,VAL &b3,VAL &z){
  VAL net0=X, net1=X;
  OR (net0, b1, b2, b3);
  OR (net1, a1, a2, a3);
  AND (z, net0, net1);
}
};
class GEN_OAI211_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b=X;
  VAL c=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X;
  OR (net0, a1, a2);
  AND (net1, net0, b, c);
  NOT (zn, net1);
}
static void function(VAL &a1,VAL &a2,VAL &b,VAL &c,VAL &zn){
  VAL net0=X, net1=X;
  OR (net0, a1, a2);
  AND (net1, net0, b, c);
  NOT (zn, net1);
}
};
class GEN_OAI211_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b=X;
  VAL c=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X;
  OR (net0, a1, a2);
  AND (net1, net0, b, c);
  NOT (zn, net1);
}
static void function(VAL &a1,VAL &a2,VAL &b,VAL &c,VAL &zn){
  VAL net0=X, net1=X;
  OR (net0, a1, a2);
  AND (net1, net0, b, c);
  NOT (zn, net1);
}
};
class GEN_OAI211_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b=X;
  VAL c=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X;
  OR (net0, a1, a2);
  AND (net1, net0, b, c);
  NOT (zn, net1);
}
static void function(VAL &a1,VAL &a2,VAL &b,VAL &c,VAL &zn){
  VAL net0=X, net1=X;
  OR (net0, a1, a2);
  AND (net1, net0, b, c);
  NOT (zn, net1);
}
};
class GEN_OAI21_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X;
  OR (net0, a1, a2);
  AND (net1, net0, b);
  NOT (zn, net1);
}
static void function(VAL &a1,VAL &a2,VAL &b,VAL &zn){
  VAL net0=X, net1=X;
  OR (net0, a1, a2);
  AND (net1, net0, b);
  NOT (zn, net1);
}
};
class GEN_OAI21_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X;
  OR (net0, a1, a2);
  AND (net1, net0, b);
  NOT (zn, net1);
}
static void function(VAL &a1,VAL &a2,VAL &b,VAL &zn){
  VAL net0=X, net1=X;
  OR (net0, a1, a2);
  AND (net1, net0, b);
  NOT (zn, net1);
}
};
class GEN_OAI21_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X;
  OR (net0, a1, a2);
  AND (net1, net0, b);
  NOT (zn, net1);
}
static void function(VAL &a1,VAL &a2,VAL &b,VAL &zn){
  VAL net0=X, net1=X;
  OR (net0, a1, a2);
  AND (net1, net0, b);
  NOT (zn, net1);
}
};
class GEN_OAI221_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b1=X;
  VAL b2=X;
  VAL c=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X, net2=X;
  OR (net0, a1, a2);
  OR (net1, b1, b2);
  AND (net2, net0, net1, c);
  NOT (zn, net2);
}
static void function(VAL &a1,VAL &a2,VAL &b1,VAL &b2,VAL &c,VAL &zn){
  VAL net0=X, net1=X, net2=X;
  OR (net0, a1, a2);
  OR (net1, b1, b2);
  AND (net2, net0, net1, c);
  NOT (zn, net2);
}
};
class GEN_OAI221_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b1=X;
  VAL b2=X;
  VAL c=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X, net2=X;
  OR (net0, a1, a2);
  OR (net1, b1, b2);
  AND (net2, net0, net1, c);
  NOT (zn, net2);
}
static void function(VAL &a1,VAL &a2,VAL &b1,VAL &b2,VAL &c,VAL &zn){
  VAL net0=X, net1=X, net2=X;
  OR (net0, a1, a2);
  OR (net1, b1, b2);
  AND (net2, net0, net1, c);
  NOT (zn, net2);
}
};
class GEN_OAI221_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b1=X;
  VAL b2=X;
  VAL c=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X, net2=X;
  OR (net0, a1, a2);
  OR (net1, b1, b2);
  AND (net2, net0, net1, c);
  NOT (zn, net2);
}
static void function(VAL &a1,VAL &a2,VAL &b1,VAL &b2,VAL &c,VAL &zn){
  VAL net0=X, net1=X, net2=X;
  OR (net0, a1, a2);
  OR (net1, b1, b2);
  AND (net2, net0, net1, c);
  NOT (zn, net2);
}
};
class GEN_OAI222_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b1=X;
  VAL b2=X;
  VAL c1=X;
  VAL c2=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X, net2=X, net3=X;
  OR (net0, c1, c2);
  OR (net1, a1, a2);
  OR (net2, b1, b2);
  AND (net3, net0, net1, net2);
  NOT (zn, net3);
}
static void function(VAL &a1,VAL &a2,VAL &b1,VAL &b2,VAL &c1,VAL &c2,VAL &zn){
  VAL net0=X, net1=X, net2=X, net3=X;
  OR (net0, c1, c2);
  OR (net1, a1, a2);
  OR (net2, b1, b2);
  AND (net3, net0, net1, net2);
  NOT (zn, net3);
}
};
class GEN_OAI222_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b1=X;
  VAL b2=X;
  VAL c1=X;
  VAL c2=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X, net2=X, net3=X;
  OR (net0, c1, c2);
  OR (net1, a1, a2);
  OR (net2, b1, b2);
  AND (net3, net0, net1, net2);
  NOT (zn, net3);
}
static void function(VAL &a1,VAL &a2,VAL &b1,VAL &b2,VAL &c1,VAL &c2,VAL &zn){
  VAL net0=X, net1=X, net2=X, net3=X;
  OR (net0, c1, c2);
  OR (net1, a1, a2);
  OR (net2, b1, b2);
  AND (net3, net0, net1, net2);
  NOT (zn, net3);
}
};
class GEN_OAI222_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b1=X;
  VAL b2=X;
  VAL c1=X;
  VAL c2=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X, net2=X, net3=X;
  OR (net0, c1, c2);
  OR (net1, a1, a2);
  OR (net2, b1, b2);
  AND (net3, net0, net1, net2);
  NOT (zn, net3);
}
static void function(VAL &a1,VAL &a2,VAL &b1,VAL &b2,VAL &c1,VAL &c2,VAL &zn){
  VAL net0=X, net1=X, net2=X, net3=X;
  OR (net0, c1, c2);
  OR (net1, a1, a2);
  OR (net2, b1, b2);
  AND (net3, net0, net1, net2);
  NOT (zn, net3);
}
};
class GEN_OAI22_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b1=X;
  VAL b2=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X, net2=X;
  OR (net0, a1, a2);
  OR (net1, b1, b2);
  AND (net2, net0, net1);
  NOT (zn, net2);
}
static void function(VAL &a1,VAL &a2,VAL &b1,VAL &b2,VAL &zn){
  VAL net0=X, net1=X, net2=X;
  OR (net0, a1, a2);
  OR (net1, b1, b2);
  AND (net2, net0, net1);
  NOT (zn, net2);
}
};
class GEN_OAI22_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b1=X;
  VAL b2=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X, net2=X;
  OR (net0, a1, a2);
  OR (net1, b1, b2);
  AND (net2, net0, net1);
  NOT (zn, net2);
}
static void function(VAL &a1,VAL &a2,VAL &b1,VAL &b2,VAL &zn){
  VAL net0=X, net1=X, net2=X;
  OR (net0, a1, a2);
  OR (net1, b1, b2);
  AND (net2, net0, net1);
  NOT (zn, net2);
}
};
class GEN_OAI22_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL b1=X;
  VAL b2=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X, net2=X;
  OR (net0, a1, a2);
  OR (net1, b1, b2);
  AND (net2, net0, net1);
  NOT (zn, net2);
}
static void function(VAL &a1,VAL &a2,VAL &b1,VAL &b2,VAL &zn){
  VAL net0=X, net1=X, net2=X;
  OR (net0, a1, a2);
  OR (net1, b1, b2);
  AND (net2, net0, net1);
  NOT (zn, net2);
}
};
class GEN_OAI31_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL b=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X;
  OR (net0, a1, a2, a3);
  AND (net1, net0, b);
  NOT (zn, net1);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &b,VAL &zn){
  VAL net0=X, net1=X;
  OR (net0, a1, a2, a3);
  AND (net1, net0, b);
  NOT (zn, net1);
}
};
class GEN_OAI31_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL b=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X;
  OR (net0, a1, a2, a3);
  AND (net1, net0, b);
  NOT (zn, net1);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &b,VAL &zn){
  VAL net0=X, net1=X;
  OR (net0, a1, a2, a3);
  AND (net1, net0, b);
  NOT (zn, net1);
}
};
class GEN_OAI31_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL b=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X;
  OR (net0, a1, a2, a3);
  AND (net1, net0, b);
  NOT (zn, net1);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &b,VAL &zn){
  VAL net0=X, net1=X;
  OR (net0, a1, a2, a3);
  AND (net1, net0, b);
  NOT (zn, net1);
}
};
class GEN_OAI32_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL b1=X;
  VAL b2=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X, net2=X;
  OR (net0, a1, a2, a3);
  OR (net1, b1, b2);
  AND (net2, net0, net1);
  NOT (zn, net2);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &b1,VAL &b2,VAL &zn){
  VAL net0=X, net1=X, net2=X;
  OR (net0, a1, a2, a3);
  OR (net1, b1, b2);
  AND (net2, net0, net1);
  NOT (zn, net2);
}
};
class GEN_OAI32_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL b1=X;
  VAL b2=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X, net2=X;
  OR (net0, a1, a2, a3);
  OR (net1, b1, b2);
  AND (net2, net0, net1);
  NOT (zn, net2);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &b1,VAL &b2,VAL &zn){
  VAL net0=X, net1=X, net2=X;
  OR (net0, a1, a2, a3);
  OR (net1, b1, b2);
  AND (net2, net0, net1);
  NOT (zn, net2);
}
};
class GEN_OAI32_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL b1=X;
  VAL b2=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X, net2=X;
  OR (net0, a1, a2, a3);
  OR (net1, b1, b2);
  AND (net2, net0, net1);
  NOT (zn, net2);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &b1,VAL &b2,VAL &zn){
  VAL net0=X, net1=X, net2=X;
  OR (net0, a1, a2, a3);
  OR (net1, b1, b2);
  AND (net2, net0, net1);
  NOT (zn, net2);
}
};
class GEN_OAI33_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL b1=X;
  VAL b2=X;
  VAL b3=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X, net2=X;
  OR (net0, a1, a2, a3);
  OR (net1, b1, b2, b3);
  AND (net2, net0, net1);
  NOT (zn, net2);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &b1,VAL &b2,VAL &b3,VAL &zn){
  VAL net0=X, net1=X, net2=X;
  OR (net0, a1, a2, a3);
  OR (net1, b1, b2, b3);
  AND (net2, net0, net1);
  NOT (zn, net2);
}
};
class GEN_OAI33_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL b1=X;
  VAL b2=X;
  VAL b3=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X, net2=X;
  OR (net0, a1, a2, a3);
  OR (net1, b1, b2, b3);
  AND (net2, net0, net1);
  NOT (zn, net2);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &b1,VAL &b2,VAL &b3,VAL &zn){
  VAL net0=X, net1=X, net2=X;
  OR (net0, a1, a2, a3);
  OR (net1, b1, b2, b3);
  AND (net2, net0, net1);
  NOT (zn, net2);
}
};
class GEN_OAI33_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL b1=X;
  VAL b2=X;
  VAL b3=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  VAL net0=X, net1=X, net2=X;
  OR (net0, a1, a2, a3);
  OR (net1, b1, b2, b3);
  AND (net2, net0, net1);
  NOT (zn, net2);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &b1,VAL &b2,VAL &b3,VAL &zn){
  VAL net0=X, net1=X, net2=X;
  OR (net0, a1, a2, a3);
  OR (net1, b1, b2, b3);
  AND (net2, net0, net1);
  NOT (zn, net2);
}
};
class GEN_OR2_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  OR (z, a1, a2);
}
static void function(VAL &a1,VAL &a2,VAL &z){
  OR (z, a1, a2);
}
};
class GEN_OR2_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  OR (z, a1, a2);
}
static void function(VAL &a1,VAL &a2,VAL &z){
  OR (z, a1, a2);
}
};
class GEN_OR2_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  OR (z, a1, a2);
}
static void function(VAL &a1,VAL &a2,VAL &z){
  OR (z, a1, a2);
}
};
class GEN_OR2_D8:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  OR (z, a1, a2);
}
static void function(VAL &a1,VAL &a2,VAL &z){
  OR (z, a1, a2);
}
};
class GEN_OR3_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  OR (z, a1, a2, a3);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &z){
  OR (z, a1, a2, a3);
}
};
class GEN_OR3_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  OR (z, a1, a2, a3);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &z){
  OR (z, a1, a2, a3);
}
};
class GEN_OR3_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  OR (z, a1, a2, a3);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &z){
  OR (z, a1, a2, a3);
}
};
class GEN_OR3_D8:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  OR (z, a1, a2, a3);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &z){
  OR (z, a1, a2, a3);
}
};
class GEN_OR4_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL a4=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  OR (z, a1, a2, a3, a4);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &a4,VAL &z){
  OR (z, a1, a2, a3, a4);
}
};
class GEN_OR4_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL a4=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  OR (z, a1, a2, a3, a4);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &a4,VAL &z){
  OR (z, a1, a2, a3, a4);
}
};
class GEN_OR4_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL a4=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  OR (z, a1, a2, a3, a4);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &a4,VAL &z){
  OR (z, a1, a2, a3, a4);
}
};
class GEN_OR4_D8:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL a4=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  OR (z, a1, a2, a3, a4);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &a4,VAL &z){
  OR (z, a1, a2, a3, a4);
}
};
class GEN_SCAN_DFCLR_D1:GATE{
public:
  VAL si=X;
  VAL d=X;
  VAL se=X;
  VAL cp=X;
  VAL cdn=X;
  VAL q=X;
  VAL notifier=X;
udp_mux2 udpi0;
udp_dff udpi1;
udp_xbuf udpi2;
udp_xbuf udpi3;
udp_xbuf udpi4;
VAL* pos()override{
 return &si;
}
void function()override{
  VAL cdn_i=X, d_i=X, q_buf=X, sd=X, si_check=X, d_check=X, se1=X, se_check=X, xsi_check=X, xd_check=X, xcdn_i=X;
  buf (cdn_i, cdn);
  VAL sdn=I;
  udpi0.function(d_i, d, si, se);
  udpi1.function(q_buf, d_i, cp, cdn_i, sdn, notifier);
  buf (q, q_buf);
  NOT (sd, se);
  AND (si_check, cdn_i, se);
  AND (d_check, cdn_i, sd);
  XOR (se1, si, d);
  AND (se_check, se1, cdn_i);
  udpi2.function(xsi_check, si_check, I);
  udpi3.function(xd_check, d_check, I);
  udpi4.function(xcdn_i, cdn_i, I);
}
};
class GEN_SCAN_DFCLR_D2:GATE{
public:
  VAL si=X;
  VAL d=X;
  VAL se=X;
  VAL cp=X;
  VAL cdn=X;
  VAL q=X;
  VAL notifier=X;
udp_mux2 udpi0;
udp_dff udpi1;
udp_xbuf udpi2;
udp_xbuf udpi3;
udp_xbuf udpi4;
VAL* pos()override{
 return &si;
}
void function()override{
  VAL cdn_i=X, d_i=X, q_buf=X, sd=X, si_check=X, d_check=X, se1=X, se_check=X, xsi_check=X, xd_check=X, xcdn_i=X;
  buf (cdn_i, cdn);
  VAL sdn=I;
  udpi0.function(d_i, d, si, se);
  udpi1.function(q_buf, d_i, cp, cdn_i, sdn, notifier);
  buf (q, q_buf);
  NOT (sd, se);
  AND (si_check, cdn_i, se);
  AND (d_check, cdn_i, sd);
  XOR (se1, si, d);
  AND (se_check, se1, cdn_i);
  udpi2.function(xsi_check, si_check, I);
  udpi3.function(xd_check, d_check, I);
  udpi4.function(xcdn_i, cdn_i, I);
}
};
class GEN_SCAN_DFCLR_D4:GATE{
public:
  VAL si=X;
  VAL d=X;
  VAL se=X;
  VAL cp=X;
  VAL cdn=X;
  VAL q=X;
  VAL notifier=X;
udp_mux2 udpi0;
udp_dff udpi1;
udp_xbuf udpi2;
udp_xbuf udpi3;
udp_xbuf udpi4;
VAL* pos()override{
 return &si;
}
void function()override{
  VAL cdn_i=X, d_i=X, q_buf=X, sd=X, si_check=X, d_check=X, se1=X, se_check=X, xsi_check=X, xd_check=X, xcdn_i=X;
  buf (cdn_i, cdn);
  VAL sdn=I;
  udpi0.function(d_i, d, si, se);
  udpi1.function(q_buf, d_i, cp, cdn_i, sdn, notifier);
  buf (q, q_buf);
  NOT (sd, se);
  AND (si_check, cdn_i, se);
  AND (d_check, cdn_i, sd);
  XOR (se1, si, d);
  AND (se_check, se1, cdn_i);
  udpi2.function(xsi_check, si_check, I);
  udpi3.function(xd_check, d_check, I);
  udpi4.function(xcdn_i, cdn_i, I);
}
};
class GEN_SCAN_DFCLR_D8:GATE{
public:
  VAL si=X;
  VAL d=X;
  VAL se=X;
  VAL cp=X;
  VAL cdn=X;
  VAL q=X;
  VAL notifier=X;
udp_mux2 udpi0;
udp_dff udpi1;
udp_xbuf udpi2;
udp_xbuf udpi3;
udp_xbuf udpi4;
VAL* pos()override{
 return &si;
}
void function()override{
  VAL cdn_i=X, d_i=X, q_buf=X, sd=X, si_check=X, d_check=X, se1=X, se_check=X, xsi_check=X, xd_check=X, xcdn_i=X;
  buf (cdn_i, cdn);
  VAL sdn=I;
  udpi0.function(d_i, d, si, se);
  udpi1.function(q_buf, d_i, cp, cdn_i, sdn, notifier);
  buf (q, q_buf);
  NOT (sd, se);
  AND (si_check, cdn_i, se);
  AND (d_check, cdn_i, sd);
  XOR (se1, si, d);
  AND (se_check, se1, cdn_i);
  udpi2.function(xsi_check, si_check, I);
  udpi3.function(xd_check, d_check, I);
  udpi4.function(xcdn_i, cdn_i, I);
}
};
class GEN_SCAN_DF_D1:GATE{
public:
  VAL si=X;
  VAL d=X;
  VAL se=X;
  VAL cp=X;
  VAL q=X;
  VAL notifier=X;
udp_mux2 udpi0;
udp_dff udpi1;
udp_xbuf udpi2;
udp_xbuf udpi3;
VAL* pos()override{
 return &si;
}
void function()override{
  VAL d_i=X, q_buf=X, sd=X, xse=X, xsd=X;
  VAL cdn=I;
  VAL sdn=I;
  udpi0.function(d_i, d, si, se);
  udpi1.function(q_buf, d_i, cp, cdn, sdn, notifier);
  buf (q, q_buf);
  NOT (sd, se);
  udpi2.function(xse, se, I);
  udpi3.function(xsd, sd, I);
}
};
class GEN_SCAN_DF_D2:GATE{
public:
  VAL si=X;
  VAL d=X;
  VAL se=X;
  VAL cp=X;
  VAL q=X;
  VAL notifier=X;
udp_mux2 udpi0;
udp_dff udpi1;
udp_xbuf udpi2;
udp_xbuf udpi3;
VAL* pos()override{
 return &si;
}
void function()override{
  VAL d_i=X, q_buf=X, sd=X, xse=X, xsd=X;
  VAL cdn=I;
  VAL sdn=I;
  udpi0.function(d_i, d, si, se);
  udpi1.function(q_buf, d_i, cp, cdn, sdn, notifier);
  buf (q, q_buf);
  NOT (sd, se);
  udpi2.function(xse, se, I);
  udpi3.function(xsd, sd, I);
}
};
class GEN_SCAN_DF_D4:GATE{
public:
  VAL si=X;
  VAL d=X;
  VAL se=X;
  VAL cp=X;
  VAL q=X;
  VAL notifier=X;
udp_mux2 udpi0;
udp_dff udpi1;
udp_xbuf udpi2;
udp_xbuf udpi3;
VAL* pos()override{
 return &si;
}
void function()override{
  VAL d_i=X, q_buf=X, sd=X, xse=X, xsd=X;
  VAL cdn=I;
  VAL sdn=I;
  udpi0.function(d_i, d, si, se);
  udpi1.function(q_buf, d_i, cp, cdn, sdn, notifier);
  buf (q, q_buf);
  NOT (sd, se);
  udpi2.function(xse, se, I);
  udpi3.function(xsd, sd, I);
}
};
class GEN_SCAN_DF_D8:GATE{
public:
  VAL si=X;
  VAL d=X;
  VAL se=X;
  VAL cp=X;
  VAL q=X;
  VAL notifier=X;
udp_mux2 udpi0;
udp_dff udpi1;
udp_xbuf udpi2;
udp_xbuf udpi3;
VAL* pos()override{
 return &si;
}
void function()override{
  VAL d_i=X, q_buf=X, sd=X, xse=X, xsd=X;
  VAL cdn=I;
  VAL sdn=I;
  udpi0.function(d_i, d, si, se);
  udpi1.function(q_buf, d_i, cp, cdn, sdn, notifier);
  buf (q, q_buf);
  NOT (sd, se);
  udpi2.function(xse, se, I);
  udpi3.function(xsd, sd, I);
}
};
class GEN_SCAN_DFSET_D1:GATE{
public:
  VAL si=X;
  VAL d=X;
  VAL se=X;
  VAL cp=X;
  VAL sdn=X;
  VAL q=X;
  VAL notifier=X;
udp_mux2 udpi0;
udp_dff udpi1;
udp_xbuf udpi2;
udp_xbuf udpi3;
udp_xbuf udpi4;
VAL* pos()override{
 return &si;
}
void function()override{
  VAL sd=Xn_i=X, d_i=X, q_buf=X, sd, si_check=X, d_check=X, xsi_check=X, xd_check=X, xsdn_i=X;
  buf (sdn_i, sdn);
  VAL cdn=I;
  udpi0.function(d_i, d, si, se);
  udpi1.function(q_buf, d_i, cp, cdn, sdn_i, notifier);
  buf (q, q_buf);
  NOT (sd, se);
  AND (si_check, sdn_i, se);
  AND (d_check, sdn_i, sd);
  udpi2.function(xsi_check, si_check, I);
  udpi3.function(xd_check, d_check, I);
  udpi4.function(xsdn_i, sdn_i, I);
}
};
class GEN_SCAN_DFSET_D2:GATE{
public:
  VAL si=X;
  VAL d=X;
  VAL se=X;
  VAL cp=X;
  VAL sdn=X;
  VAL q=X;
  VAL notifier=X;
udp_mux2 udpi0;
udp_dff udpi1;
udp_xbuf udpi2;
udp_xbuf udpi3;
udp_xbuf udpi4;
VAL* pos()override{
 return &si;
}
void function()override{
  VAL sd=Xn_i=X, d_i=X, q_buf=X, sd, si_check=X, d_check=X, xsi_check=X, xd_check=X, xsdn_i=X;
  buf (sdn_i, sdn);
  VAL cdn=I;
  udpi0.function(d_i, d, si, se);
  udpi1.function(q_buf, d_i, cp, cdn, sdn_i, notifier);
  buf (q, q_buf);
  NOT (sd, se);
  AND (si_check, sdn_i, se);
  AND (d_check, sdn_i, sd);
  udpi2.function(xsi_check, si_check, I);
  udpi3.function(xd_check, d_check, I);
  udpi4.function(xsdn_i, sdn_i, I);
}
};
class GEN_SCAN_DFSET_D4:GATE{
public:
  VAL si=X;
  VAL d=X;
  VAL se=X;
  VAL cp=X;
  VAL sdn=X;
  VAL q=X;
  VAL notifier=X;
udp_mux2 udpi0;
udp_dff udpi1;
udp_xbuf udpi2;
udp_xbuf udpi3;
udp_xbuf udpi4;
VAL* pos()override{
 return &si;
}
void function()override{
  VAL sd=Xn_i=X, d_i=X, q_buf=X, sd, si_check=X, d_check=X, xsi_check=X, xd_check=X, xsdn_i=X;
  buf (sdn_i, sdn);
  VAL cdn=I;
  udpi0.function(d_i, d, si, se);
  udpi1.function(q_buf, d_i, cp, cdn, sdn_i, notifier);
  buf (q, q_buf);
  NOT (sd, se);
  AND (si_check, sdn_i, se);
  AND (d_check, sdn_i, sd);
  udpi2.function(xsi_check, si_check, I);
  udpi3.function(xd_check, d_check, I);
  udpi4.function(xsdn_i, sdn_i, I);
}
};
class GEN_SCAN_DFSET_D8:GATE{
public:
  VAL si=X;
  VAL d=X;
  VAL se=X;
  VAL cp=X;
  VAL sdn=X;
  VAL q=X;
  VAL notifier=X;
udp_mux2 udpi0;
udp_dff udpi1;
udp_xbuf udpi2;
udp_xbuf udpi3;
udp_xbuf udpi4;
VAL* pos()override{
 return &si;
}
void function()override{
  VAL sd=Xn_i=X, d_i=X, q_buf=X, sd, si_check=X, d_check=X, xsi_check=X, xd_check=X, xsdn_i=X;
  buf (sdn_i, sdn);
  VAL cdn=I;
  udpi0.function(d_i, d, si, se);
  udpi1.function(q_buf, d_i, cp, cdn, sdn_i, notifier);
  buf (q, q_buf);
  NOT (sd, se);
  AND (si_check, sdn_i, se);
  AND (d_check, sdn_i, sd);
  udpi2.function(xsi_check, si_check, I);
  udpi3.function(xd_check, d_check, I);
  udpi4.function(xsdn_i, sdn_i, I);
}
};
class GEN_XNOR2_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  XNOR (zn, a1, a2);
}
static void function(VAL &a1,VAL &a2,VAL &zn){
  XNOR (zn, a1, a2);
}
};
class GEN_XNOR2_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  XNOR (zn, a1, a2);
}
static void function(VAL &a1,VAL &a2,VAL &zn){
  XNOR (zn, a1, a2);
}
};
class GEN_XNOR2_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  XNOR (zn, a1, a2);
}
static void function(VAL &a1,VAL &a2,VAL &zn){
  XNOR (zn, a1, a2);
}
};
class GEN_XNOR2_D8:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  XNOR (zn, a1, a2);
}
static void function(VAL &a1,VAL &a2,VAL &zn){
  XNOR (zn, a1, a2);
}
};
class GEN_XNOR3_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  XNOR (zn, a1, a2, a3);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &zn){
  XNOR (zn, a1, a2, a3);
}
};
class GEN_XNOR3_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  XNOR (zn, a1, a2, a3);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &zn){
  XNOR (zn, a1, a2, a3);
}
};
class GEN_XNOR3_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL zn=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  XNOR (zn, a1, a2, a3);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &zn){
  XNOR (zn, a1, a2, a3);
}
};
class GEN_XOR2_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  XOR (z, a1, a2);
}
static void function(VAL &a1,VAL &a2,VAL &z){
  XOR (z, a1, a2);
}
};
class GEN_XOR2_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  XOR (z, a1, a2);
}
static void function(VAL &a1,VAL &a2,VAL &z){
  XOR (z, a1, a2);
}
};
class GEN_XOR2_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  XOR (z, a1, a2);
}
static void function(VAL &a1,VAL &a2,VAL &z){
  XOR (z, a1, a2);
}
};
class GEN_XOR2_D8:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  XOR (z, a1, a2);
}
static void function(VAL &a1,VAL &a2,VAL &z){
  XOR (z, a1, a2);
}
};
class GEN_XOR3_D1:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  XOR (z, a1, a2, a3);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &z){
  XOR (z, a1, a2, a3);
}
};
class GEN_XOR3_D2:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  XOR (z, a1, a2, a3);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &z){
  XOR (z, a1, a2, a3);
}
};
class GEN_XOR3_D4:GATE{
public:
  VAL a1=X;
  VAL a2=X;
  VAL a3=X;
  VAL z=X;
VAL* pos()override{
 return &a1;
}
void function()override{
  XOR (z, a1, a2, a3);
}
static void function(VAL &a1,VAL &a2,VAL &a3,VAL &z){
  XOR (z, a1, a2, a3);
}
};
class GEN_CLKGATE_D1:GATE{
public:
  VAL te=X;
  VAL e=X;
  VAL cp=X;
  VAL q=X;
  VAL qd=X;
VAL* pos()override{
 return &te;
}
void function()override{
  if ( IO == cp || IX == cp || XO == cp)
    {
       qd = te | e;
    }
   q = cp & qd;
}
static void function(VAL &te,VAL &e,VAL &cp,VAL &q){
  if ( IO == cp || IX == cp || XO == cp)
    {
       qd = te | e;
    }
   q = cp & qd;
}
};
class GEN_SYNC2C_D1:GATE{
public:
  VAL clk=X;
  VAL d=X;
  VAL clr_=X;
  VAL q=X;
  VAL d0=X;
VAL* pos()override{
 return &clk;
}
void function()override{
  if ( OI == clk || OX == clk || XI == clk ||  IO == clr_ || IX == clr_ || XO == clr_)
    {
      if(!clr_ == I || !clr_ == OI || !clr_ == XI )
        q = 0 ;
      else
        q = d0;
        if(!clr_ == I || !clr_ == OI || !clr_ == XI )
          d0 = 0 ;
        else
          d0 = d;
    }
}
static void function(VAL &clk,VAL &d,VAL &clr_,VAL &q){
  if ( OI == clk || OX == clk || XI == clk ||  IO == clr_ || IX == clr_ || XO == clr_)
    {
      if(!clr_ == I || !clr_ == OI || !clr_ == XI )
        q = 0 ;
      else
        q = d0;
        if(!clr_ == I || !clr_ == OI || !clr_ == XI )
          d0 = 0 ;
        else
          d0 = d;
    }
}
};
class GEN_SYNC3_D1:GATE{
public:
  VAL clk=X;
  VAL d=X;
  VAL q=X;
  VAL d1=X, d0=X;
VAL* pos()override{
 return &clk;
}
void function()override{
  if ( OI == clk || OX == clk || XI == clk)
    {
      q = d1;
      d1 = d0;
      d0 = d;
    }
}
static void function(VAL &clk,VAL &d,VAL &q){
  if ( OI == clk || OX == clk || XI == clk)
    {
      q = d1;
      d1 = d0;
      d0 = d;
    }
}
};
class GEN_SYNC3S_D1:GATE{
public:
  VAL clk=X;
  VAL d=X;
  VAL set_=X;
  VAL q=X;
  VAL d1=X,d0=X;
VAL* pos()override{
 return &clk;
}
void function()override{
  if ( OI == clk || OX == clk || XI == clk ||  IO == set_ || IX == set_ || XO == set_)
    {
      if(!set_ == I || !set_ == OI || !set_ == XI )
        q = 1;
      else
        q = d1;
        if(!set_ == I || !set_ == OI || !set_ == XI )
          d1 = 1;
        else
          d1 = d0;
          if(!set_ == I || !set_ == OI || !set_ == XI )
            d0 = 1;
          else
            d0 = d;
    }
}
static void function(VAL &clk,VAL &d,VAL &set_,VAL &q){
  if ( OI == clk || OX == clk || XI == clk ||  IO == set_ || IX == set_ || XO == set_)
    {
      if(!set_ == I || !set_ == OI || !set_ == XI )
        q = 1;
      else
        q = d1;
        if(!set_ == I || !set_ == OI || !set_ == XI )
          d1 = 1;
        else
          d1 = d0;
          if(!set_ == I || !set_ == OI || !set_ == XI )
            d0 = 1;
          else
            d0 = d;
    }
}
};
class GEN_RAMS_16X272:GATE{
public:
  VAL clk=X;
  VAL ra [4];
  VAL re=X;
  VAL wa [4];
  VAL we=X;
  VAL di [272];
  VAL dout [272];
  VAL ra_d [4];
  VAL M [16] [272];
VAL* pos()override{
 return &clk;
}
void function()override{
  VAL dout [272];
  if (  OI == clk || OX == clk || XI == clk ) {
    if (we == I || we == OI || we == XI )
for(int i=0;i<sizeof( di);i++)
      M[num(wa,sizeof(wa))] [i] =  di[i];
    }
  if (  OI == clk || OX == clk || XI == clk ) {
    if (re == I || re == OI || re == XI )
for(int i=0;i<sizeof( ra);i++)
      ra_d [i] =  ra[i];
    }
for(int i=0;i<sizeof( M[num(ra_d,sizeof(ra_d))]);i++)
   dout [i] =  M[num(ra_d,sizeof(ra_d))][i];
}
};
class GEN_RAMS_16X256:GATE{
public:
  VAL clk=X;
  VAL ra [4];
  VAL re=X;
  VAL wa [4];
  VAL we=X;
  VAL di [256];
  VAL dout [256];
  VAL ra_d [4];
  VAL M [16] [256];
VAL* pos()override{
 return &clk;
}
void function()override{
  VAL dout [256];
  if (  OI == clk || OX == clk || XI == clk ) {
    if (we == I || we == OI || we == XI )
for(int i=0;i<sizeof( di);i++)
      M[num(wa,sizeof(wa))] [i] =  di[i];
    }
  if (  OI == clk || OX == clk || XI == clk ) {
    if (re == I || re == OI || re == XI )
for(int i=0;i<sizeof( ra);i++)
      ra_d [i] =  ra[i];
    }
for(int i=0;i<sizeof( M[num(ra_d,sizeof(ra_d))]);i++)
    dout [i] =  M[num(ra_d,sizeof(ra_d))][i];
}
};
class GEN_RAMS_OLAT_80x14:GATE{
public:
  VAL clk=X;
  VAL ra [7];
  VAL re=X;
  VAL ore=X;
  VAL wa [7];
  VAL we=X;
  VAL di [14];
  VAL dout [14];
  VAL ra_d [7];
  VAL M [80] [14];
  VAL dout_r [14];
VAL* pos()override{
 return &clk;
}
void function()override{
  VAL dout [14];
  VAL dout_ram [14];
  if (  OI == clk || OX == clk || XI == clk ) {
    if (we == I || we == OI || we == XI )
for(int i=0;i<sizeof( di);i++)
      M[num(wa,sizeof(wa))] [i] =  di[i];
  }
  if (  OI == clk || OX == clk || XI == clk ) {
    if (re == I || re == OI || re == XI )
for(int i=0;i<sizeof( ra);i++)
      ra_d [i] =  ra[i];
  }
for(int i=0;i<sizeof( M[num(ra_d,sizeof(ra_d))]);i++)
   dout_ram [i] =  M[num(ra_d,sizeof(ra_d))][i];
  if (  OI == clk || OX == clk || XI == clk ) {
   if (ore == I || ore == OI || ore == XI )
for(int i=0;i<sizeof( dout_ram);i++)
     dout_r [i] =  dout_ram[i];
  }
for(int i=0;i<sizeof( dout_r);i++)
   dout [i] =  dout_r[i];
}
};
class GEN_RAMS_OLAT_80x65:GATE{
public:
  VAL clk=X;
  VAL ra [7];
  VAL re=X;
  VAL ore=X;
  VAL wa [7];
  VAL we=X;
  VAL di [65];
  VAL dout [65];
  VAL ra_d [7];
  VAL M [80] [65];
  VAL dout_r [65];
VAL* pos()override{
 return &clk;
}
void function()override{
  VAL dout [65];
  VAL dout_ram [65];
  if (  OI == clk || OX == clk || XI == clk ) {
    if (we == I || we == OI || we == XI )
for(int i=0;i<sizeof( di);i++)
      M[num(wa,sizeof(wa))] [i] =  di[i];
  }
  if (  OI == clk || OX == clk || XI == clk ) {
    if (re == I || re == OI || re == XI )
for(int i=0;i<sizeof( ra);i++)
      ra_d [i] =  ra[i];
  }
for(int i=0;i<sizeof( M[num(ra_d,sizeof(ra_d))]);i++)
   dout_ram [i] =  M[num(ra_d,sizeof(ra_d))][i];
  if (  OI == clk || OX == clk || XI == clk ) {
    if (ore == I || ore == OI || ore == XI )
for(int i=0;i<sizeof( dout_ram);i++)
      dout_r [i] =  dout_ram[i];
  }
for(int i=0;i<sizeof( dout_r);i++)
   dout [i] =  dout_r[i];
}
};
class GEN_RAMS_OLAT_160x16:GATE{
public:
  VAL clk=X;
  VAL ra [8];
  VAL re=X;
  VAL ore=X;
  VAL wa [8];
  VAL we=X;
  VAL di [16];
  VAL dout [16];
  VAL ra_d [8];
  VAL M [160] [16];
  VAL dout_r [16];
VAL* pos()override{
 return &clk;
}
void function()override{
  VAL dout [16];
  VAL dout_ram [16];
  if (  OI == clk || OX == clk || XI == clk ) {
    if (we == I || we == OI || we == XI )
for(int i=0;i<sizeof( di);i++)
      M[num(wa,sizeof(wa))] [i] =  di[i];
  }
  if (  OI == clk || OX == clk || XI == clk ) {
    if (re == I || re == OI || re == XI )
for(int i=0;i<sizeof( ra);i++)
      ra_d [i] =  ra[i];
  }
for(int i=0;i<sizeof( M[num(ra_d,sizeof(ra_d))]);i++)
   dout_ram [i] =  M[num(ra_d,sizeof(ra_d))][i];
  if (  OI == clk || OX == clk || XI == clk ) {
    if (ore == I || ore == OI || ore == XI )
for(int i=0;i<sizeof( dout_ram);i++)
      dout_r [i] =  dout_ram[i];
  }
for(int i=0;i<sizeof( dout_r);i++)
   dout [i] =  dout_r[i];
}
};
class GEN_RAMS_OLAT_160x65:GATE{
public:
  VAL clk=X;
  VAL ra [8];
  VAL re=X;
  VAL ore=X;
  VAL wa [8];
  VAL we=X;
  VAL di [65];
  VAL dout [65];
  VAL ra_d [8];
  VAL M [160] [65];
  VAL dout_r [65];
VAL* pos()override{
 return &clk;
}
void function()override{
  VAL dout [65];
  VAL dout_ram [65];
  if (  OI == clk || OX == clk || XI == clk ) {
    if (we == I || we == OI || we == XI )
for(int i=0;i<sizeof( di);i++)
      M[num(wa,sizeof(wa))] [i] =  di[i];
  }
  if (  OI == clk || OX == clk || XI == clk ) {
    if (re == I || re == OI || re == XI )
for(int i=0;i<sizeof( ra);i++)
      ra_d [i] =  ra[i];
  }
for(int i=0;i<sizeof( M[num(ra_d,sizeof(ra_d))]);i++)
   dout_ram [i] =  M[num(ra_d,sizeof(ra_d))][i];
  if (  OI == clk || OX == clk || XI == clk ) {
    if (ore == I || ore == OI || ore == XI )
for(int i=0;i<sizeof( dout_ram);i++)
      dout_r [i] =  dout_ram[i];
  }
for(int i=0;i<sizeof( dout_r);i++)
   dout [i] =  dout_r[i];
}
};
class GEN_RAMS_OLAT_8x65:GATE{
public:
  VAL clk=X;
  VAL ra [3];
  VAL re=X;
  VAL ore=X;
  VAL wa [3];
  VAL we=X;
  VAL di [65];
  VAL dout [65];
  VAL ra_d [3];
  VAL M [8] [65];
  VAL dout_r [65];
VAL* pos()override{
 return &clk;
}
void function()override{
  VAL dout [65];
  VAL dout_ram [65];
  if (  OI == clk || OX == clk || XI == clk ) {
    if (we == I || we == OI || we == XI )
for(int i=0;i<sizeof( di);i++)
      M[num(wa,sizeof(wa))] [i] =  di[i];
  }
  if (  OI == clk || OX == clk || XI == clk ) {
    if (re == I || re == OI || re == XI )
for(int i=0;i<sizeof( ra);i++)
      ra_d [i] =  ra[i];
  }
for(int i=0;i<sizeof( M[num(ra_d,sizeof(ra_d))]);i++)
   dout_ram [i] =  M[num(ra_d,sizeof(ra_d))][i];
  if (  OI == clk || OX == clk || XI == clk ) {
    if (ore == I || ore == OI || ore == XI )
for(int i=0;i<sizeof( dout_ram);i++)
      dout_r [i] =  dout_ram[i];
  }
for(int i=0;i<sizeof( dout_r);i++)
   dout [i] =  dout_r[i];
}
};
class GEN_RAMS_OLAT_128x6:GATE{
public:
  VAL clk=X;
  VAL ra [7];
  VAL re=X;
  VAL ore=X;
  VAL wa [7];
  VAL we=X;
  VAL di [6];
  VAL dout [6];
  VAL ra_d [7];
  VAL M [128] [6];
  VAL dout_r [6];
VAL* pos()override{
 return &clk;
}
void function()override{
  VAL dout [6];
  VAL dout_ram [6];
  if (  OI == clk || OX == clk || XI == clk ) {
    if (we == I || we == OI || we == XI )
for(int i=0;i<sizeof( di);i++)
      M[num(wa,sizeof(wa))] [i] =  di[i];
  }
  if (  OI == clk || OX == clk || XI == clk ) {
    if (re == I || re == OI || re == XI )
for(int i=0;i<sizeof( ra);i++)
      ra_d [i] =  ra[i];
  }
for(int i=0;i<sizeof( M[num(ra_d,sizeof(ra_d))]);i++)
   dout_ram [i] =  M[num(ra_d,sizeof(ra_d))][i];
  if (  OI == clk || OX == clk || XI == clk ) {
    if (ore == I || ore == OI || ore == XI )
for(int i=0;i<sizeof( dout_ram);i++)
      dout_r [i] =  dout_ram[i];
  }
for(int i=0;i<sizeof( dout_r);i++)
   dout [i] =  dout_r[i];
}
};
class GEN_RAMS_256x64:GATE{
public:
  VAL clk=X;
  VAL ra [8];
  VAL re=X;
  VAL wa [8];
  VAL we=X;
  VAL di [64];
  VAL dout [64];
  VAL ra_d [8];
  VAL M [256] [64];
VAL* pos()override{
 return &clk;
}
void function()override{
  VAL dout [64];
  if (  OI == clk || OX == clk || XI == clk ) {
    if (we == I || we == OI || we == XI )
for(int i=0;i<sizeof( di);i++)
      M[num(wa,sizeof(wa))] [i] =  di[i];
  }
  if (  OI == clk || OX == clk || XI == clk ) {
    if (re == I || re == OI || re == XI )
for(int i=0;i<sizeof( ra);i++)
      ra_d [i] =  ra[i];
  }
for(int i=0;i<sizeof( M[num(ra_d,sizeof(ra_d))]);i++)
   dout [i] =  M[num(ra_d,sizeof(ra_d))][i];
}
};
class GEN_RAMS_16x64:GATE{
public:
  VAL clk=X;
  VAL ra [4];
  VAL re=X;
  VAL wa [4];
  VAL we=X;
  VAL di [64];
  VAL dout [64];
  VAL ra_d [4];
  VAL M [16] [64];
VAL* pos()override{
 return &clk;
}
void function()override{
  VAL dout [64];
  if (  OI == clk || OX == clk || XI == clk ) {
    if (we == I || we == OI || we == XI )
for(int i=0;i<sizeof( di);i++)
      M[num(wa,sizeof(wa))] [i] =  di[i];
  }
  if (  OI == clk || OX == clk || XI == clk ) {
    if (re == I || re == OI || re == XI )
for(int i=0;i<sizeof( ra);i++)
      ra_d [i] =  ra[i];
  }
for(int i=0;i<sizeof( M[num(ra_d,sizeof(ra_d))]);i++)
   dout [i] =  M[num(ra_d,sizeof(ra_d))][i];
}
};
class GEN_RAMS_OLAT_128x11:GATE{
public:
  VAL clk=X;
  VAL ra [7];
  VAL re=X;
  VAL ore=X;
  VAL wa [7];
  VAL we=X;
  VAL di [11];
  VAL dout [11];
  VAL ra_d [7];
  VAL M [128] [11];
  VAL dout_r [11];
VAL* pos()override{
 return &clk;
}
void function()override{
  VAL dout [11];
  VAL dout_ram [11];
  if (  OI == clk || OX == clk || XI == clk ) {
    if (we == I || we == OI || we == XI )
for(int i=0;i<sizeof( di);i++)
      M[num(wa,sizeof(wa))] [i] =  di[i];
  }
  if (  OI == clk || OX == clk || XI == clk ) {
    if (re == I || re == OI || re == XI )
for(int i=0;i<sizeof( ra);i++)
      ra_d [i] =  ra[i];
  }
for(int i=0;i<sizeof( M[num(ra_d,sizeof(ra_d))]);i++)
   dout_ram [i] =  M[num(ra_d,sizeof(ra_d))][i];
  if (  OI == clk || OX == clk || XI == clk ) {
    if (ore == I || ore == OI || ore == XI )
for(int i=0;i<sizeof( dout_ram);i++)
      dout_r [i] =  dout_ram[i];
  }
for(int i=0;i<sizeof( dout_r);i++)
   dout [i] =  dout_r[i];
}
};
class GEN_RAMS_OLAT_61x65:GATE{
public:
  VAL clk=X;
  VAL ra [6];
  VAL re=X;
  VAL ore=X;
  VAL wa [6];
  VAL we=X;
  VAL di [65];
  VAL dout [65];
  VAL ra_d [6];
  VAL M [61] [65];
  VAL dout_r [65];
VAL* pos()override{
 return &clk;
}
void function()override{
  VAL dout [65];
  VAL dout_ram [65];
  if (  OI == clk || OX == clk || XI == clk ) {
    if (we == I || we == OI || we == XI )
for(int i=0;i<sizeof( di);i++)
      M[num(wa,sizeof(wa))] [i] =  di[i];
  }
  if (  OI == clk || OX == clk || XI == clk ) {
    if (re == I || re == OI || re == XI )
for(int i=0;i<sizeof( ra);i++)
      ra_d [i] =  ra[i];
  }
for(int i=0;i<sizeof( M[num(ra_d,sizeof(ra_d))]);i++)
   dout_ram [i] =  M[num(ra_d,sizeof(ra_d))][i];
  if (  OI == clk || OX == clk || XI == clk ) {
    if (ore == I || ore == OI || ore == XI )
for(int i=0;i<sizeof( dout_ram);i++)
      dout_r [i] =  dout_ram[i];
  }
for(int i=0;i<sizeof( dout_r);i++)
   dout [i] =  dout_r[i];
}
};
class GEN_RAMS_WT_IPASS_OLAT_80x9:GATE{
public:
  VAL clk=X;
  VAL ra [7];
  VAL re=X;
  VAL ore=X;
  VAL wa [7];
  VAL we=X;
  VAL di [9];
  VAL byp_sel=X;
  VAL dbyp [9];
  VAL dout [9];
  VAL ra_d [7];
  VAL M [80] [9];
  VAL dout_r [9];
VAL* pos()override{
 return &clk;
}
void function()override{
  VAL dout [9];
  VAL dout_ram [9] ;
  VAL fbypass_dout_ram [9];
  if (  OI == clk || OX == clk || XI == clk ) {
    if (we == I || we == OI || we == XI )
for(int i=0;i<sizeof( di);i++)
      M[num(wa,sizeof(wa))] [i] =  di[i];
  }
  if (  OI == clk || OX == clk || XI == clk ) {
    if (re == I || re == OI || re == XI )
for(int i=0;i<sizeof( ra);i++)
      ra_d [i] =  ra[i];
  }
for(int i=0;i<sizeof( M[num(ra_d,sizeof(ra_d))]);i++)
   dout_ram [i] =  M[num(ra_d,sizeof(ra_d))][i];
  if(byp_sel == I || byp_sel == OI || byp_sel == XI )
for(int i=0;i<sizeof( dbyp);i++)
    fbypass_dout_ram [i] =  dbyp[i];
  else
for(int i=0;i<sizeof( dout_ram);i++)
    fbypass_dout_ram [i] =  dout_ram[i];
  if (  OI == clk || OX == clk || XI == clk ) {
    if (ore == I || ore == OI || ore == XI )
for(int i=0;i<sizeof( fbypass_dout_ram);i++)
      dout_r [i] =  fbypass_dout_ram[i];
  }
for(int i=0;i<sizeof( dout_r);i++)
   dout [i] =  dout_r[i];
}
};
class GEN_RAMS_WT_IPASS_OLAT_80x15:GATE{
public:
  VAL clk=X;
  VAL ra [7];
  VAL re=X;
  VAL ore=X;
  VAL wa [7];
  VAL we=X;
  VAL di [15];
  VAL byp_sel=X;
  VAL dbyp [15];
  VAL dout [15];
  VAL ra_d [7];
  VAL M [80] [15];
  VAL dout_r [15];
VAL* pos()override{
 return &clk;
}
void function()override{
  VAL dout [15];
  VAL dout_ram [15];
  VAL fbypass_dout_ram [15]
  if (  OI == clk || OX == clk || XI == clk ) {
    if (we == I || we == OI || we == XI )
for(int i=0;i<sizeof( di);i++)
      M[num(wa,sizeof(wa))] [i] =  di[i];
  }
  if (  OI == clk || OX == clk || XI == clk ) {
    if (re == I || re == OI || re == XI )
for(int i=0;i<sizeof( ra);i++)
      ra_d [i] =  ra[i];
  }
for(int i=0;i<sizeof( M[num(ra_d,sizeof(ra_d))]);i++)
   dout_ram [i] =  M[num(ra_d,sizeof(ra_d))][i];
  if(byp_sel == I || byp_sel == OI || byp_sel == XI )
for(int i=0;i<sizeof( dbyp);i++)
    fbypass_dout_ram [i] =  dbyp[i];
  else
for(int i=0;i<sizeof( dout_ram);i++)
    fbypass_dout_ram [i] =  dout_ram[i];
  if (  OI == clk || OX == clk || XI == clk ) {
    if (ore == I || ore == OI || ore == XI )
for(int i=0;i<sizeof( fbypass_dout_ram);i++)
      dout_r [i] =  fbypass_dout_ram[i];
  }
for(int i=0;i<sizeof( dout_r);i++)
   dout [i] =  dout_r[i];
}
};
class GEN_RAMS_WT_IPASS_OLAT_60x21:GATE{
public:
  VAL clk=X;
  VAL ra [6];
  VAL re=X;
  VAL ore=X;
  VAL wa [6];
  VAL we=X;
  VAL di [21];
  VAL byp_sel=X;
  VAL dbyp [21];
  VAL dout [21];
  VAL ra_d [6];
  VAL M [60] [21];
  VAL dout_r [21];
VAL* pos()override{
 return &clk;
}
void function()override{
  VAL dout [21];
  VAL dout_ram [21] ;
  VAL fbypass_dout_ram [21];
  if (  OI == clk || OX == clk || XI == clk ) {
    if (we == I || we == OI || we == XI )
for(int i=0;i<sizeof( di);i++)
      M[num(wa,sizeof(wa))] [i] =  di[i];
  }
  if (  OI == clk || OX == clk || XI == clk ) {
    if (re == I || re == OI || re == XI )
for(int i=0;i<sizeof( ra);i++)
      ra_d [i] =  ra[i];
  }
for(int i=0;i<sizeof( M[num(ra_d,sizeof(ra_d))]);i++)
  dout_ram [i] =  M[num(ra_d,sizeof(ra_d))][i];
  if(byp_sel == I || byp_sel == OI || byp_sel == XI )
for(int i=0;i<sizeof( dbyp);i++)
    fbypass_dout_ram [i] =  dbyp[i];
  else
for(int i=0;i<sizeof( dout_ram);i++)
    fbypass_dout_ram [i] =  dout_ram[i];
  if (  OI == clk || OX == clk || XI == clk ) {
    if (ore == I || ore == OI || ore == XI )
for(int i=0;i<sizeof( fbypass_dout_ram);i++)
      dout_r [i] =  fbypass_dout_ram[i];
  }
for(int i=0;i<sizeof( dout_r);i++)
   dout [i] =  dout_r[i];
}
};
class GEN_RAMS_WT_256x8:GATE{
public:
  VAL clk=X;
  VAL ra [8];
  VAL re=X;
  VAL wa [8];
  VAL we=X;
  VAL di [8];
  VAL dout [8];
  VAL ra_d [8];
  VAL M [256] [8];
VAL* pos()override{
 return &clk;
}
void function()override{
  VAL dout [8];
  if (  OI == clk || OX == clk || XI == clk ) {
    if (we == I || we == OI || we == XI )
for(int i=0;i<sizeof( di);i++)
      M[num(wa,sizeof(wa))] [i] =  di[i];
  }
  if (  OI == clk || OX == clk || XI == clk ) {
    if (re == I || re == OI || re == XI )
for(int i=0;i<sizeof( ra);i++)
      ra_d [i] =  ra[i];
  }
for(int i=0;i<sizeof( M[num(ra_d,sizeof(ra_d))]);i++)
   dout [i] =  M[num(ra_d,sizeof(ra_d))][i];
}
};
class GEN_RAMS_256x7:GATE{
public:
  VAL clk=X;
  VAL ra [8];
  VAL re=X;
  VAL wa [8];
  VAL we=X;
  VAL di [7];
  VAL dout [7];
  VAL ra_d [8];
  VAL M [256] [7];
VAL* pos()override{
 return &clk;
}
void function()override{
  VAL dout [7];
  if (  OI == clk || OX == clk || XI == clk ) {
    if (we == I || we == OI || we == XI )
for(int i=0;i<sizeof( di);i++)
      M[num(wa,sizeof(wa))] [i] =  di[i];
  }
  if (  OI == clk || OX == clk || XI == clk ) {
    if (re == I || re == OI || re == XI )
for(int i=0;i<sizeof( ra);i++)
      ra_d [i] =  ra[i];
  }
for(int i=0;i<sizeof( M[num(ra_d,sizeof(ra_d))]);i++)
   dout [i] =  M[num(ra_d,sizeof(ra_d))][i];
}
};
class GEN_RAMS_256x3:GATE{
public:
  VAL clk=X;
  VAL ra [8];
  VAL re=X;
  VAL wa [8];
  VAL we=X;
  VAL di [3];
  VAL dout [3];
  VAL ra_d [8];
  VAL M [256] [3];
VAL* pos()override{
 return &clk;
}
void function()override{
  VAL dout [3];
  if (  OI == clk || OX == clk || XI == clk ) {
    if (we == I || we == OI || we == XI )
for(int i=0;i<sizeof( di);i++)
      M[num(wa,sizeof(wa))] [i] =  di[i];
  }
  if (  OI == clk || OX == clk || XI == clk ) {
    if (re == I || re == OI || re == XI )
for(int i=0;i<sizeof( ra);i++)
      ra_d [i] =  ra[i];
  }
for(int i=0;i<sizeof( M[num(ra_d,sizeof(ra_d))]);i++)
   dout [i] =  M[num(ra_d,sizeof(ra_d))][i];
}
};
class GEN_RAMS_WT_IPASS_OLAT_19x4:GATE{
public:
  VAL clk=X;
  VAL ra [5];
  VAL re=X;
  VAL ore=X;
  VAL wa [5];
  VAL we=X;
  VAL di [4];
  VAL byp_sel=X;
  VAL dbyp [4];
  VAL dout [4];
  VAL ra_d [5];
  VAL M [19] [4];
  VAL dout_r [4];
VAL* pos()override{
 return &clk;
}
void function()override{
  VAL dout [4];
  VAL dout_ram [4];
  VAL fbypass_dout_ram [4] ;
  if (  OI == clk || OX == clk || XI == clk ) {
    if (we == I || we == OI || we == XI )
for(int i=0;i<sizeof( di);i++)
      M[num(wa,sizeof(wa))] [i] =  di[i];
  }
  if (  OI == clk || OX == clk || XI == clk ) {
    if (re == I || re == OI || re == XI )
for(int i=0;i<sizeof( ra);i++)
      ra_d [i] =  ra[i];
  }
for(int i=0;i<sizeof( M[num(ra_d,sizeof(ra_d))]);i++)
  dout_ram [i] =  M[num(ra_d,sizeof(ra_d))][i];
  if(byp_sel == I || byp_sel == OI || byp_sel == XI )
for(int i=0;i<sizeof( dbyp);i++)
    fbypass_dout_ram [i] =  dbyp[i];
  else
for(int i=0;i<sizeof( dout_ram);i++)
    fbypass_dout_ram [i] =  dout_ram[i];
  if (  OI == clk || OX == clk || XI == clk ) {
    if (ore == I || ore == OI || ore == XI )
for(int i=0;i<sizeof( fbypass_dout_ram);i++)
      dout_r [i] =  fbypass_dout_ram[i];
  }
for(int i=0;i<sizeof( dout_r);i++)
   dout [i] =  dout_r[i];
}
};
class GEN_RAMS_128x18:GATE{
public:
  VAL clk=X;
  VAL ra [7];
  VAL re=X;
  VAL wa [7];
  VAL we=X;
  VAL di [18];
  VAL dout [18];
  VAL ra_d [7];
  VAL M [128] [18];
VAL* pos()override{
 return &clk;
}
void function()override{
  VAL dout [18];
  if (  OI == clk || OX == clk || XI == clk ) {
    if (we == I || we == OI || we == XI )
for(int i=0;i<sizeof( di);i++)
      M[num(wa,sizeof(wa))] [i] =  di[i];
  }
  if (  OI == clk || OX == clk || XI == clk ) {
    if (re == I || re == OI || re == XI )
for(int i=0;i<sizeof( ra);i++)
      ra_d [i] =  ra[i];
  }
for(int i=0;i<sizeof( M[num(ra_d,sizeof(ra_d))]);i++)
   dout [i] =  M[num(ra_d,sizeof(ra_d))][i];
}
};
class GEN_SYNC3C_D1:GATE{
public:
  VAL clk=X ;
  VAL d=X ;
  VAL clr_=X ;
  VAL q=X ;
  VAL d1=X,d0=X;
VAL* pos()override{
 return &clk;
}
void function()override{
  if ( OI == clk || OX == clk || XI == clk ||  IO == clr_ || IX == clr_ || XO == clr_)
  {
    if(!clr_ == I || !clr_ == OI || !clr_ == XI )
      q = 0 ;
    else
      q = d1;
      if(!clr_ == I || !clr_ == OI || !clr_ == XI )
        d1 = 0;
      else
        d1 = d0;
        if(!clr_ == I || !clr_ == OI || !clr_ == XI )
          d0 = 0;
        else
          d0 = d;
  }
}
static void function(VAL &clk,VAL &d,VAL &clr_,VAL &q){
  if ( OI == clk || OX == clk || XI == clk ||  IO == clr_ || IX == clr_ || XO == clr_)
  {
    if(!clr_ == I || !clr_ == OI || !clr_ == XI )
      q = 0 ;
    else
      q = d1;
      if(!clr_ == I || !clr_ == OI || !clr_ == XI )
        d1 = 0;
      else
        d1 = d0;
        if(!clr_ == I || !clr_ == OI || !clr_ == XI )
          d0 = 0;
        else
          d0 = d;
  }
}
};
class GEN_SYNC3C_STRICT_D1:GATE{
public:
  VAL src_d_next=X ;
  VAL src_clk=X ;
  VAL src_clrn=X ;
  VAL dst_clk=X ;
  VAL dst_clrn=X ;
  VAL atpg_ctl=X ;
  VAL test_mode=X ;
  VAL src_d=X ;
  VAL dst_q=X ;
  VAL  src_d_f=X;
VAL* pos()override{
 return &src_d_next;
}
void function()override{
  VAL src_sel=X,dst_sel=X;
   src_sel = src_d_next;
  if ( OI == src_clk || OX == src_clk || XI == src_clk ||  IO == src_clrn || IX == src_clrn || XO == src_clrn)
  {
    if(!src_clrn == I || !src_clrn == OI || !src_clrn == XI )
      src_d_f = O;
    else
      src_d_f = src_sel;
  }
   src_d = src_d_f;
   dst_sel = src_d_f;
GEN_SYNC3C_D1::function(dst_clk,dst_sel,dst_clrn,dst_q);
}
static void function(VAL &src_d_next,VAL &src_clk,VAL &src_clrn,VAL &dst_clk,VAL &dst_clrn,VAL &src_d,VAL &dst_q,VAL &atpg_ctl,VAL &test_mode){
  VAL src_sel=X,dst_sel=X;
   src_sel = src_d_next;
  if ( OI == src_clk || OX == src_clk || XI == src_clk ||  IO == src_clrn || IX == src_clrn || XO == src_clrn)
  {
    if(!src_clrn == I || !src_clrn == OI || !src_clrn == XI )
      src_d_f = O;
    else
      src_d_f = src_sel;
  }
   src_d = src_d_f;
   dst_sel = src_d_f;
GEN_SYNC3C_D1::function(dst_clk,dst_sel,dst_clrn,dst_q);
}
};
class GEN_RAMS_512x256:GATE{
public:
VAL clk=X;
VAL ra [9];
VAL re=X;
VAL wa [9];
VAL we=X;
VAL di [256];
VAL dout [256];
VAL ra_d [9];
VAL M [512] [256];
VAL* pos()override{
 return &clk;
}
void function()override{
VAL dout [256];
  if (  OI == clk || OX == clk || XI == clk ) {
    if (we == I || we == OI || we == XI )
for(int i=0;i<sizeof( di);i++)
      M[num(wa,sizeof(wa))] [i] =  di[i];
  }
  if (  OI == clk || OX == clk || XI == clk ) {
    if (re == I || re == OI || re == XI )
for(int i=0;i<sizeof( ra);i++)
      ra_d [i] =  ra[i];
  }
for(int i=0;i<sizeof( M[num(ra_d,sizeof(ra_d))]);i++)
   dout [i] =  M[num(ra_d,sizeof(ra_d))][i];
}
};
class GEN_RAMS_64x116:GATE{
public:
VAL clk=X;
VAL ra [6];
VAL re=X;
VAL wa [6];
VAL we=X;
VAL di [116];
VAL dout [116];
VAL ra_d [6];
VAL M [64] [116];
VAL* pos()override{
 return &clk;
}
void function()override{
VAL dout [116];
  if (  OI == clk || OX == clk || XI == clk ) {
    if (we == I || we == OI || we == XI )
for(int i=0;i<sizeof( di);i++)
      M[num(wa,sizeof(wa))] [i] =  di[i];
  }
  if (  OI == clk || OX == clk || XI == clk ) {
    if (re == I || re == OI || re == XI )
for(int i=0;i<sizeof( ra);i++)
      ra_d [i] =  ra[i];
  }
for(int i=0;i<sizeof( M[num(ra_d,sizeof(ra_d))]);i++)
   dout [i] =  M[num(ra_d,sizeof(ra_d))][i];
}
};
class GEN_RAMS_64x1088:GATE{
public:
VAL clk=X;
VAL ra [6];
VAL re=X;
VAL wa [6];
VAL we=X;
VAL di [1088];
VAL dout [1088];
VAL ra_d [6];
VAL M [64] [1088];
VAL* pos()override{
 return &clk;
}
void function()override{
VAL dout [1088];
  if (  OI == clk || OX == clk || XI == clk ) {
    if (we == I || we == OI || we == XI )
for(int i=0;i<sizeof( di);i++)
      M[num(wa,sizeof(wa))] [i] =  di[i];
  }
  if (  OI == clk || OX == clk || XI == clk ) {
    if (re == I || re == OI || re == XI )
for(int i=0;i<sizeof( ra);i++)
      ra_d [i] =  ra[i];
  }
for(int i=0;i<sizeof( M[num(ra_d,sizeof(ra_d))]);i++)
   dout [i] =  M[num(ra_d,sizeof(ra_d))][i];
}
};
class GEN_RAMS_64x1024:GATE{
public:
VAL clk=X;
VAL ra [6];
VAL re=X;
VAL wa [6];
VAL we=X;
VAL di [1024];
VAL dout [1024];
VAL ra_d [6];
VAL M [64] [1024];
VAL* pos()override{
 return &clk;
}
void function()override{
VAL dout [1024];
  if (  OI == clk || OX == clk || XI == clk ) {
    if (we == I || we == OI || we == XI )
for(int i=0;i<sizeof( di);i++)
      M[num(wa,sizeof(wa))] [i] =  di[i];
  }
  if (  OI == clk || OX == clk || XI == clk ) {
    if (re == I || re == OI || re == XI )
for(int i=0;i<sizeof( ra);i++)
      ra_d [i] =  ra[i];
  }
for(int i=0;i<sizeof( M[num(ra_d,sizeof(ra_d))]);i++)
   dout [i] =  M[num(ra_d,sizeof(ra_d))][i];
}
};
class GEN_RAMS_OLAT_256x14:GATE{
public:
VAL clk=X;
VAL ra [8];
VAL re=X;
VAL ore=X;
VAL wa [8];
VAL we=X;
VAL di [14];
VAL dout [14];
VAL ra_d [8];
VAL M [256] [14];
  VAL dout_r [14];
VAL* pos()override{
 return &clk;
}
void function()override{
VAL dout [14];
  VAL dout_ram [14];
  if (  OI == clk || OX == clk || XI == clk ) {
    if (we == I || we == OI || we == XI )
for(int i=0;i<sizeof( di);i++)
      M[num(wa,sizeof(wa))] [i] =  di[i];
  }
  if (  OI == clk || OX == clk || XI == clk ) {
    if (re == I || re == OI || re == XI )
for(int i=0;i<sizeof( ra);i++)
      ra_d [i] =  ra[i];
  }
for(int i=0;i<sizeof( M[num(ra_d,sizeof(ra_d))]);i++)
  dout_ram [i] =  M[num(ra_d,sizeof(ra_d))][i];
  if (  OI == clk || OX == clk || XI == clk ) {
   if (ore == I || ore == OI || ore == XI )
for(int i=0;i<sizeof( dout_ram);i++)
     dout_r [i] =  dout_ram[i];
  }
for(int i=0;i<sizeof( dout_r);i++)
   dout [i] =  dout_r[i];
}
};
class GEN_RAMS_OLAT_256x16:GATE{
public:
VAL clk=X;
VAL ra [8];
VAL re=X;
VAL ore=X;
VAL wa [8];
VAL we=X;
VAL di [16];
VAL dout [16];
VAL ra_d [8];
VAL M [256] [16];
  VAL dout_r [16];
VAL* pos()override{
 return &clk;
}
void function()override{
VAL dout [16];
  VAL dout_ram [16];
  if (  OI == clk || OX == clk || XI == clk ) {
    if (we == I || we == OI || we == XI )
for(int i=0;i<sizeof( di);i++)
      M[num(wa,sizeof(wa))] [i] =  di[i];
  }
  if (  OI == clk || OX == clk || XI == clk ) {
    if (re == I || re == OI || re == XI )
for(int i=0;i<sizeof( ra);i++)
      ra_d [i] =  ra[i];
  }
for(int i=0;i<sizeof( M[num(ra_d,sizeof(ra_d))]);i++)
  dout_ram [i] =  M[num(ra_d,sizeof(ra_d))][i];
  if (  OI == clk || OX == clk || XI == clk ) {
   if (ore == I || ore == OI || ore == XI )
for(int i=0;i<sizeof( dout_ram);i++)
     dout_r [i] =  dout_ram[i];
  }
for(int i=0;i<sizeof( dout_r);i++)
   dout [i] =  dout_r[i];
}
};
class GEN_RAMS_OLAT_256x257:GATE{
public:
VAL clk=X;
VAL ra [8];
VAL re=X;
VAL ore=X;
VAL wa [8];
VAL we=X;
VAL di [257];
VAL dout [257];
VAL ra_d [8];
VAL M [256] [257];
  VAL dout_r [257];
VAL* pos()override{
 return &clk;
}
void function()override{
VAL dout [257];
  VAL dout_ram [257];
  if (  OI == clk || OX == clk || XI == clk ) {
    if (we == I || we == OI || we == XI )
for(int i=0;i<sizeof( di);i++)
      M[num(wa,sizeof(wa))] [i] =  di[i];
  }
  if (  OI == clk || OX == clk || XI == clk ) {
    if (re == I || re == OI || re == XI )
for(int i=0;i<sizeof( ra);i++)
      ra_d [i] =  ra[i];
  }
for(int i=0;i<sizeof( M[num(ra_d,sizeof(ra_d))]);i++)
  dout_ram [i] =  M[num(ra_d,sizeof(ra_d))][i];
  if (  OI == clk || OX == clk || XI == clk ) {
   if (ore == I || ore == OI || ore == XI )
for(int i=0;i<sizeof( dout_ram);i++)
     dout_r [i] =  dout_ram[i];
  }
for(int i=0;i<sizeof( dout_r);i++)
   dout [i] =  dout_r[i];
}
};
class GEN_RAMS_OLAT_8x257:GATE{
public:
VAL clk=X;
VAL ra [3];
VAL re=X;
VAL ore=X;
VAL wa [3];
VAL we=X;
VAL di [257];
VAL dout [257];
VAL ra_d [3];
VAL M [8] [257];
  VAL dout_r [257];
VAL* pos()override{
 return &clk;
}
void function()override{
VAL dout [257];
  VAL dout_ram [257];
  if (  OI == clk || OX == clk || XI == clk ) {
    if (we == I || we == OI || we == XI )
for(int i=0;i<sizeof( di);i++)
      M[num(wa,sizeof(wa))] [i] =  di[i];
  }
  if (  OI == clk || OX == clk || XI == clk ) {
    if (re == I || re == OI || re == XI )
for(int i=0;i<sizeof( ra);i++)
      ra_d [i] =  ra[i];
  }
for(int i=0;i<sizeof( M[num(ra_d,sizeof(ra_d))]);i++)
  dout_ram [i] =  M[num(ra_d,sizeof(ra_d))][i];
  if (  OI == clk || OX == clk || XI == clk ) {
   if (ore == I || ore == OI || ore == XI )
for(int i=0;i<sizeof( dout_ram);i++)
     dout_r [i] =  dout_ram[i];
  }
for(int i=0;i<sizeof( dout_r);i++)
   dout [i] =  dout_r[i];
}
};
class GEN_RAMS_WT_IPASS_OLAT_80x72:GATE{
public:
VAL clk=X;
VAL ra [7];
VAL re=X;
VAL ore=X;
VAL wa [7];
VAL we=X;
VAL di [72];
VAL byp_sel=X;
VAL dbyp [72];
VAL dout [72];
VAL ra_d [7];
VAL M [80] [72];
  VAL dout_r [72];
VAL* pos()override{
 return &clk;
}
void function()override{
VAL dout [72];
  VAL dout_ram [72] ;
  VAL fbypass_dout_ram [72];
  if (  OI == clk || OX == clk || XI == clk ) {
    if (we == I || we == OI || we == XI )
for(int i=0;i<sizeof( di);i++)
      M[num(wa,sizeof(wa))] [i] =  di[i];
  }
  if (  OI == clk || OX == clk || XI == clk ) {
    if (re == I || re == OI || re == XI )
for(int i=0;i<sizeof( ra);i++)
      ra_d [i] =  ra[i];
  }
for(int i=0;i<sizeof( M[num(ra_d,sizeof(ra_d))]);i++)
  dout_ram [i] =  M[num(ra_d,sizeof(ra_d))][i];
  if(byp_sel == I || byp_sel == OI || byp_sel == XI )
for(int i=0;i<sizeof( dbyp);i++)
    fbypass_dout_ram [i] =  dbyp[i];
  else
for(int i=0;i<sizeof( dout_ram);i++)
    fbypass_dout_ram [i] =  dout_ram[i];
  if (  OI == clk || OX == clk || XI == clk ) {
    if (ore == I || ore == OI || ore == XI )
for(int i=0;i<sizeof( fbypass_dout_ram);i++)
      dout_r [i] =  fbypass_dout_ram[i];
  }
for(int i=0;i<sizeof( dout_r);i++)
   dout [i] =  dout_r[i];
}
};
class GEN_RAMS_WT_IPASS_OLAT_80x17:GATE{
public:
VAL clk=X;
VAL ra [7];
VAL re=X;
VAL ore=X;
VAL wa [7];
VAL we=X;
VAL di [17];
VAL byp_sel=X;
VAL dbyp [17];
VAL dout [17];
VAL ra_d [7];
VAL M [80] [17];
  VAL dout_r [17];
VAL* pos()override{
 return &clk;
}
void function()override{
VAL dout [17];
  VAL dout_ram [17] ;
  VAL fbypass_dout_ram [17] ;
  if (  OI == clk || OX == clk || XI == clk ) {
    if (we == I || we == OI || we == XI )
for(int i=0;i<sizeof( di);i++)
      M[num(wa,sizeof(wa))] [i] =  di[i];
  }
  if (  OI == clk || OX == clk || XI == clk ) {
    if (re == I || re == OI || re == XI )
for(int i=0;i<sizeof( ra);i++)
      ra_d [i] =  ra[i];
  }
for(int i=0;i<sizeof( M[num(ra_d,sizeof(ra_d))]);i++)
  dout_ram [i] =  M[num(ra_d,sizeof(ra_d))][i];
  if(byp_sel == I || byp_sel == OI || byp_sel == XI )
for(int i=0;i<sizeof( dbyp);i++)
    fbypass_dout_ram [i] =  dbyp[i];
  else
for(int i=0;i<sizeof( dout_ram);i++)
    fbypass_dout_ram [i] =  dout_ram[i];
  if (  OI == clk || OX == clk || XI == clk ) {
    if (ore == I || ore == OI || ore == XI )
for(int i=0;i<sizeof( fbypass_dout_ram);i++)
      dout_r [i] =  fbypass_dout_ram[i];
  }
for(int i=0;i<sizeof( dout_r);i++)
   dout [i] =  dout_r[i];
}
};
class GEN_RAMS_WT_IPASS_OLAT_60x168:GATE{
public:
VAL clk=X;
VAL ra [6];
VAL re=X;
VAL ore=X;
VAL wa [6];
VAL we=X;
VAL di [168];
VAL byp_sel=X;
VAL dbyp [168];
VAL dout [168];
VAL ra_d [6];
VAL M [60] [168];
  VAL dout_r [168];
VAL* pos()override{
 return &clk;
}
void function()override{
VAL dout [168];
  VAL dout_ram [168];
  VAL fbypass_dout_ram [168] ;
  if (  OI == clk || OX == clk || XI == clk ) {
    if (we == I || we == OI || we == XI )
for(int i=0;i<sizeof( di);i++)
      M[num(wa,sizeof(wa))] [i] =  di[i];
  }
  if (  OI == clk || OX == clk || XI == clk ) {
    if (re == I || re == OI || re == XI )
for(int i=0;i<sizeof( ra);i++)
      ra_d [i] =  ra[i];
  }
for(int i=0;i<sizeof( M[num(ra_d,sizeof(ra_d))]);i++)
  dout_ram [i] =  M[num(ra_d,sizeof(ra_d))][i];
  if(byp_sel == I || byp_sel == OI || byp_sel == XI )
for(int i=0;i<sizeof( dbyp);i++)
    fbypass_dout_ram [i] =  dbyp[i];
  else
for(int i=0;i<sizeof( dout_ram);i++)
    fbypass_dout_ram [i] =  dout_ram[i];
  if (  OI == clk || OX == clk || XI == clk ) {
    if (ore == I || ore == OI || ore == XI )
for(int i=0;i<sizeof( fbypass_dout_ram);i++)
      dout_r [i] =  fbypass_dout_ram[i];
  }
for(int i=0;i<sizeof( dout_r);i++)
   dout [i] =  dout_r[i];
}
};
class GEN_RAMS_WT_IPASS_OLAT_20x32:GATE{
public:
VAL clk=X;
VAL ra [5];
VAL re=X;
VAL ore=X;
VAL wa [5];
VAL we=X;
VAL di [32];
VAL byp_sel=X;
VAL dbyp [32];
VAL dout [32];
VAL ra_d [5];
VAL M [20] [32];
  VAL dout_r [32];
VAL* pos()override{
 return &clk;
}
void function()override{
VAL dout [32];
  VAL dout_ram [32];
  VAL fbypass_dout_ram [32] ;
  if (  OI == clk || OX == clk || XI == clk ) {
    if (we == I || we == OI || we == XI )
for(int i=0;i<sizeof( di);i++)
      M[num(wa,sizeof(wa))] [i] =  di[i];
  }
  if (  OI == clk || OX == clk || XI == clk ) {
    if (re == I || re == OI || re == XI )
for(int i=0;i<sizeof( ra);i++)
      ra_d [i] =  ra[i];
  }
for(int i=0;i<sizeof( M[num(ra_d,sizeof(ra_d))]);i++)
  dout_ram [i] =  M[num(ra_d,sizeof(ra_d))][i];
  if(byp_sel == I || byp_sel == OI || byp_sel == XI )
for(int i=0;i<sizeof( dbyp);i++)
    fbypass_dout_ram [i] =  dbyp[i];
  else
for(int i=0;i<sizeof( dout_ram);i++)
    fbypass_dout_ram [i] =  dout_ram[i];
  if (  OI == clk || OX == clk || XI == clk ) {
    if (ore == I || ore == OI || ore == XI )
for(int i=0;i<sizeof( fbypass_dout_ram);i++)
      dout_r [i] =  fbypass_dout_ram[i];
  }
for(int i=0;i<sizeof( dout_r);i++)
   dout [i] =  dout_r[i];
}
};
class GEN_RAMS_SP_WENABLE21_64x21:GATE{
public:
VAL clk=X;
VAL a [6];
VAL we=X;
VAL wce=X;
VAL re=X;
VAL di [21];
VAL dout [21];
VAL    M [64][21];
VAL ra_d [6];
VAL* pos()override{
 return &clk;
}
void function()override{
if (  OI == clk || OX == clk || XI == clk ) {
  if ( ( we & wce ) == I ) {
for(int i=0;i<sizeof( di);i++)
    M[num(a,sizeof(a))] [i] =  di[i];
  }
  if ( re == I ) {
for(int i=0;i<sizeof( a);i++)
    ra_d [i] =  a[i];
  }
}
for(int i=0;i<sizeof( M[num(ra_d,sizeof(ra_d))]);i++)
 dout [i] =  M[num(ra_d,sizeof(ra_d))][i];
}
};
class GEN_RAMS_SP_WENABLE32_1024x32:GATE{
public:
VAL clk=X;
VAL a [10];
VAL we=X;
VAL wce=X;
VAL re=X;
VAL di [32];
VAL dout [32];
VAL    M [1024][32];
VAL ra_d [10];
VAL* pos()override{
 return &clk;
}
void function()override{
if (  OI == clk || OX == clk || XI == clk ) {
  if ( ( we & wce ) == I ) {
for(int i=0;i<sizeof( di);i++)
    M[num(a,sizeof(a))] [i] =  di[i];
  }
  if ( re == I ) {
for(int i=0;i<sizeof( a);i++)
    ra_d [i] =  a[i];
  }
}
for(int i=0;i<sizeof( M[num(ra_d,sizeof(ra_d))]);i++)
 dout [i] =  M[num(ra_d,sizeof(ra_d))][i];
}
};
class GEN_RAMS_SP_WENABLE8_4096x32:GATE{
public:
VAL clk=X;
VAL a [12];
VAL we [4];
VAL wce=X;
VAL re=X;
VAL di [32];
VAL dout [32];
VAL    M [4096][32];
VAL ra_d [12];
VAL* pos()override{
 return &clk;
}
void function()override{
if (  OI == clk || OX == clk || XI == clk ) {
  if ( ( we[0] & wce ) == I ) {
for(int i=0;i<=7;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( ( we[1] & wce ) == I ) {
for(int i=8;i<=15;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( ( we[2] & wce ) == I ) {
for(int i=16;i<=23;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( ( we[3] & wce ) == I ) {
for(int i=24;i<=31;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( re == I ) {
for(int i=0;i<sizeof( a);i++)
    ra_d [i] =  a[i];
  }
}
for(int i=0;i<sizeof( M[num(ra_d,sizeof(ra_d))]);i++)
 dout [i] =  M[num(ra_d,sizeof(ra_d))][i];
}
};
class GEN_RAMS_SP_WENABLE22_64x88:GATE{
public:
VAL clk=X;
VAL a [6];
VAL we [4];
VAL wce=X;
VAL re=X;
VAL di [88];
VAL dout [88];
VAL    M [64][88];
VAL ra_d [6];
VAL* pos()override{
 return &clk;
}
void function()override{
if (  OI == clk || OX == clk || XI == clk ) {
  if ( ( we[0] & wce ) == I ) {
for(int i=0;i<=21;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( ( we[1] & wce ) == I ) {
for(int i=22;i<=43;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( ( we[2] & wce ) == I ) {
for(int i=44;i<=65;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( ( we[3] & wce ) == I ) {
for(int i=66;i<=87;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( re == I ) {
for(int i=0;i<sizeof( a);i++)
    ra_d [i] =  a[i];
  }
}
for(int i=0;i<sizeof( M[num(ra_d,sizeof(ra_d))]);i++)
 dout [i] =  M[num(ra_d,sizeof(ra_d))][i];
}
};
class GEN_RAMS_SP_WENABLE8_512x256:GATE{
public:
VAL clk=X;
VAL a [9];
VAL we [32];
VAL wce=X;
VAL re=X;
VAL di [256];
VAL dout [256];
VAL    M [512][256];
VAL ra_d [9];
VAL* pos()override{
 return &clk;
}
void function()override{
if (  OI == clk || OX == clk || XI == clk ) {
  if ( ( we[0] & wce ) == I ) {
for(int i=0;i<=7;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( ( we[1] & wce ) == I ) {
for(int i=8;i<=15;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( ( we[2] & wce ) == I ) {
for(int i=16;i<=23;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( ( we[3] & wce ) == I ) {
for(int i=24;i<=31;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( ( we[4] & wce ) == I ) {
for(int i=32;i<=39;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( ( we[5] & wce ) == I ) {
for(int i=40;i<=47;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( ( we[6] & wce ) == I ) {
for(int i=48;i<=55;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( ( we[7] & wce ) == I ) {
for(int i=56;i<=63;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( ( we[8] & wce ) == I ) {
for(int i=64;i<=71;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( ( we[9] & wce ) == I ) {
for(int i=72;i<=79;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( ( we[10] & wce ) == I ) {
for(int i=80;i<=87;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( ( we[11] & wce ) == I ) {
for(int i=88;i<=95;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( ( we[12] & wce ) == I ) {
for(int i=96;i<=103;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( ( we[13] & wce ) == I ) {
for(int i=104;i<=111;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( ( we[14] & wce ) == I ) {
for(int i=112;i<=119;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( ( we[15] & wce ) == I ) {
for(int i=120;i<=127;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( ( we[16] & wce ) == I ) {
for(int i=128;i<=135;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( ( we[17] & wce ) == I ) {
for(int i=136;i<=143;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( ( we[18] & wce ) == I ) {
for(int i=144;i<=151;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( ( we[19] & wce ) == I ) {
for(int i=152;i<=159;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( ( we[20] & wce ) == I ) {
for(int i=160;i<=167;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( ( we[21] & wce ) == I ) {
for(int i=168;i<=175;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( ( we[22] & wce ) == I ) {
for(int i=176;i<=183;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( ( we[23] & wce ) == I ) {
for(int i=184;i<=191;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( ( we[24] & wce ) == I ) {
for(int i=192;i<=199;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( ( we[25] & wce ) == I ) {
for(int i=200;i<=207;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( ( we[26] & wce ) == I ) {
for(int i=208;i<=215;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( ( we[27] & wce ) == I ) {
for(int i=216;i<=223;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( ( we[28] & wce ) == I ) {
for(int i=224;i<=231;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( ( we[29] & wce ) == I ) {
for(int i=232;i<=239;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( ( we[30] & wce ) == I ) {
for(int i=240;i<=247;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( ( we[31] & wce ) == I ) {
for(int i=248;i<=255;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( re == I ) {
for(int i=0;i<sizeof( a);i++)
    ra_d [i] =  a[i];
  }
}
for(int i=0;i<sizeof( M[num(ra_d,sizeof(ra_d))]);i++)
 dout [i] =  M[num(ra_d,sizeof(ra_d))][i];
}
};
class GEN_RAMS_SP_WENABLE21_64x84:GATE{
public:
VAL clk=X;
VAL a [6];
VAL we [4];
VAL wce=X;
VAL re=X;
VAL di [84];
VAL dout [84];
VAL    M [64][84];
VAL ra_d [6];
VAL* pos()override{
 return &clk;
}
void function()override{
if (  OI == clk || OX == clk || XI == clk ) {
  if ( ( we[0] & wce ) == I ) {
for(int i=0;i<=20;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( ( we[1] & wce ) == I ) {
for(int i=21;i<=41;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( ( we[2] & wce ) == I ) {
for(int i=42;i<=62;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( ( we[3] & wce ) == I ) {
for(int i=63;i<=83;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( re == I ) {
for(int i=0;i<sizeof( a);i++)
    ra_d [i] =  a[i];
  }
}
for(int i=0;i<sizeof( M[num(ra_d,sizeof(ra_d))]);i++)
 dout [i] =  M[num(ra_d,sizeof(ra_d))][i];
}
};
class GEN_RAMS_SP_WENABLE32_512x128:GATE{
public:
VAL clk=X;
VAL a [9];
VAL we [4];
VAL wce=X;
VAL re=X;
VAL di [128];
VAL dout [128];
VAL    M [512][128];
VAL ra_d [9];
VAL* pos()override{
 return &clk;
}
void function()override{
if (  OI == clk || OX == clk || XI == clk ) {
  if ( ( we[0] & wce ) == I ) {
for(int i=0;i<=31;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( ( we[1] & wce ) == I ) {
for(int i=32;i<=63;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( ( we[2] & wce ) == I ) {
for(int i=64;i<=95;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( ( we[3] & wce ) == I ) {
for(int i=96;i<=127;i++)
    M[num(a,sizeof(a))][i]  =  di[i];
  }
  if ( re == I ) {
for(int i=0;i<sizeof( a);i++)
    ra_d [i] =  a[i];
  }
}
for(int i=0;i<sizeof( M[num(ra_d,sizeof(ra_d))]);i++)
 dout [i] =  M[num(ra_d,sizeof(ra_d))][i];
}
};
